# æ•°æ®ç»“æ„ä¸ç®—æ³•

by ä¿¡æ¯ç§‘å­¦æŠ€æœ¯å­¦é™¢ å´ä¸€å‡¡          2024.6

### ä¸€.é€»è¾‘ç»“æ„

**é€»è¾‘ç»“æ„æ­ç¤ºäº†æ•°æ®å…ƒç´ ä¹‹é—´çš„é€»è¾‘å…³ç³»**ã€‚é€»è¾‘ç»“æ„å¯åˆ†ä¸ºâ€œçº¿æ€§â€å’Œâ€œéçº¿æ€§â€ä¸¤å¤§ç±»ã€‚çº¿æ€§ç»“æ„æ¯”è¾ƒç›´è§‚ï¼ŒæŒ‡æ•°æ®åœ¨é€»è¾‘å…³ç³»ä¸Šå‘ˆçº¿æ€§æ’åˆ—ï¼›éçº¿æ€§ç»“æ„åˆ™ç›¸åï¼Œå‘ˆéçº¿æ€§æ’åˆ—ã€‚

#### ï¼ˆ1ï¼‰çº¿æ€§æ•°æ®ç»“æ„ï¼šçº¿æ€§æ•°æ®ç»“æ„æ˜¯ä¸€ç§æŒ‰ç…§çº¿æ€§é¡ºåºæ’åˆ—å…ƒç´ çš„æ•°æ®ç»“æ„ã€‚

â€‹         å…¶ä¸­åŒ…æ‹¬ï¼š

â€‹         1.åˆ—è¡¨ï¼ˆListï¼‰ï¼šåˆ—è¡¨æ˜¯ä¸€ç§æœ‰åºçš„å¯å˜åºåˆ—ï¼Œå¯ä»¥å­˜å‚¨å¤šä¸ªå…ƒç´ ï¼Œå¹¶ä¸”å¯ä»¥æ ¹æ®ç´¢å¼•è®¿é—®å’Œä¿®æ”¹å…ƒç´ ã€‚

â€‹         2.å…ƒç»„ï¼ˆTupleï¼‰ï¼šå…ƒç»„æ˜¯ä¸€ç§ä¸å¯å˜åºåˆ—ï¼Œç±»ä¼¼äºåˆ—è¡¨ï¼Œä½†æ˜¯å…ƒç»„çš„å…ƒç´ ä¸èƒ½è¢«ä¿®æ”¹ã€‚

â€‹         3.å­—ç¬¦ä¸²ï¼ˆStringï¼‰ï¼šå­—ç¬¦ä¸²æ˜¯ä¸€ç§æœ‰åºçš„å­—ç¬¦åºåˆ—ï¼Œå¯ä»¥é€šè¿‡ç´¢å¼•è®¿é—®å’Œæ“ä½œå…¶ä¸­çš„å­—ç¬¦ã€‚

#### ï¼ˆ2ï¼‰éçº¿æ€§æ•°æ®ç»“æ„ï¼šéçº¿æ€§æ•°æ®ç»“æ„æ˜¯ä¸æŒ‰ç…§çº¿æ€§é¡ºåºæ’åˆ—å…ƒç´ çš„æ•°æ®ç»“æ„ã€‚

â€‹         å…¶ä¸­åŒ…æ‹¬ï¼š

â€‹         1.å­—å…¸ï¼ˆDictionaryï¼‰ï¼šå­—å…¸æ˜¯ä¸€ç§é”®å€¼å¯¹çš„æ˜ å°„ç»“æ„ï¼Œå¯ä»¥æ ¹æ®é”®æ¥è®¿é—®å’Œä¿®æ”¹å¯¹åº”çš„å€¼ã€‚

â€‹         2.é›†åˆï¼ˆSetï¼‰ï¼šé›†åˆæ˜¯ä¸€ç§æ— åºä¸”ä¸é‡å¤çš„æ•°æ®ç»“æ„ï¼Œç”¨äºå­˜å‚¨å”¯ä¸€çš„å…ƒç´ ã€‚

â€‹         3.æ ‘ï¼ˆTreeï¼‰ï¼šæ ‘æ˜¯ä¸€ç§å±‚æ¬¡ç»“æ„ï¼Œç”±èŠ‚ç‚¹å’Œè¾¹ç»„æˆï¼Œå…¶ä¸­ä¸€ä¸ªèŠ‚ç‚¹è¢«ç§°ä¸ºæ ¹èŠ‚ç‚¹ï¼Œæ¯ä¸ªèŠ‚ç‚¹å¯ä»¥æœ‰é›¶ä¸ªæˆ–å¤šä¸ªå­èŠ‚ç‚¹ã€‚

â€‹         4.å›¾ï¼ˆGraphï¼‰ï¼šå›¾æ˜¯ç”±èŠ‚ç‚¹å’Œè¾¹ç»„æˆçš„æ•°æ®ç»“æ„ï¼Œå…¶ä¸­èŠ‚ç‚¹å¯ä»¥æ˜¯ä»»æ„å¯¹è±¡ï¼Œè¾¹è¡¨ç¤ºèŠ‚ç‚¹ä¹‹é—´çš„å…³ç³»ã€‚

##### çº¿æ€§æ•°æ®ç»“æ„é€‚ç”¨äºæŒ‰ç…§é¡ºåºå­˜å‚¨å’Œè®¿é—®å…ƒç´ çš„åœºæ™¯ï¼Œè€Œéçº¿æ€§æ•°æ®ç»“æ„é€‚ç”¨äºæ›´å¤æ‚çš„æ•°æ®å…³ç³»å’Œç»“æ„çš„è¡¨ç¤ºå’Œæ“ä½œã€‚

### äºŒ.çº¿æ€§è¡¨

çº¿æ€§è¡¨çš„ç‰¹ç‚¹æ˜¯å…ƒç´ ä¹‹é—´æŒ‰ç…§ä¸€å®šçš„é¡ºåºæ’åˆ—ï¼Œæ¯ä¸ªå…ƒç´ æœ‰ä¸”åªæœ‰ä¸€ä¸ªç›´æ¥å‰é©±å’Œä¸€ä¸ªç›´æ¥åç»§ï¼ˆé™¤äº†ç¬¬ä¸€ä¸ªå…ƒç´ æ²¡æœ‰å‰é©±ï¼Œæœ€åä¸€ä¸ªå…ƒç´ æ²¡æœ‰åç»§ï¼‰ã€‚çº¿æ€§è¡¨åˆå¯ä»¥åˆ†ä¸ºé¡ºåºè¡¨å’Œé“¾è¡¨ã€‚

#### ï¼ˆ1ï¼‰é¡ºåºè¡¨

é¡ºåºè¡¨ä½¿ç”¨è¿ç»­çš„å†…å­˜ç©ºé—´æ¥å­˜å‚¨å…ƒç´ ã€‚é¡ºåºè¡¨ä¸­çš„å…ƒç´ æŒ‰ç…§é¡ºåºä¾æ¬¡å­˜æ”¾ï¼Œå¯ä»¥é€šè¿‡ç´¢å¼•æ¥è®¿é—®å’Œä¿®æ”¹å…ƒç´ ã€‚åˆ—è¡¨ï¼ˆListï¼‰å°±æ˜¯ä¸€ç§å¸¸è§çš„é¡ºåºè¡¨å®ç°ã€‚

```python
class SequentialList:
    def __init__(self, n):
        self.data = list(range(n))

    def is_empty(self):
        return len(self.data) == 0
    
    def length(self):
        return len(self.data)
    
    def append(self, item):
        self.data.append(item)
    
    def insert(self, index, item):
        self.data.insert(index, item)
    
    def delete(self, index):
        if 0 <= index < len(self.data):
            del self.data[index]
        else:
            return IndexError('Index out of range')
    
    def get(self, index):
        if 0 <= index < len(self.data):
            return self.data[index]
        else:
            return IndexError('Index out of range')
    
    def set(self, index, target):
        if 0 <= index < len(self.data):
            self.data[index] = target
        else:
            return IndexError('Index out of range')
    
    def display(self):
        print(self.data)

lst = SequentialList(n)
```

é¡ºåºè¡¨çš„ä¼˜ç‚¹æ˜¯å¯ä»¥å¿«é€Ÿåœ°è®¿é—®ä»»æ„ä½ç½®çš„å…ƒç´ ï¼Œå› ä¸ºå¯ä»¥é€šè¿‡ç´¢å¼•ç›´æ¥è®¡ç®—å‡ºå…ƒç´ çš„å†…å­˜åœ°å€ã€‚æ­¤å¤–ï¼Œé¡ºåºè¡¨è¿˜å¯ä»¥åŠ¨æ€åœ°è°ƒæ•´å¤§å°ï¼Œå³åœ¨éœ€è¦æ—¶å¯ä»¥åŠ¨æ€åœ°æ·»åŠ æˆ–åˆ é™¤å…ƒç´ ã€‚

é¡ºåºè¡¨çš„ç¼ºç‚¹æ˜¯åœ¨æ’å…¥å’Œåˆ é™¤å…ƒç´ æ—¶å¯èƒ½éœ€è¦ç§»åŠ¨å¤§é‡å…ƒç´ ï¼Œè¿™ä¼šå¸¦æ¥è¾ƒé«˜çš„æ—¶é—´å¤æ‚åº¦ã€‚å¦å¤–ï¼Œé¡ºåºè¡¨çš„å¤§å°æ˜¯å›ºå®šçš„ï¼Œéœ€è¦æå‰åˆ†é…è¶³å¤Ÿçš„å†…å­˜ç©ºé—´ï¼Œå¦‚æœå…ƒç´ æ•°é‡è¶…è¿‡äº†åˆ†é…çš„ç©ºé—´ï¼Œå°±éœ€è¦é‡æ–°åˆ†é…æ›´å¤§çš„ç©ºé—´å¹¶å°†ç°æœ‰å…ƒç´ å¤åˆ¶åˆ°æ–°çš„ç©ºé—´ä¸­ã€‚

#### ï¼ˆ2ï¼‰é“¾è¡¨

é“¾è¡¨ä½¿ç”¨ç¦»æ•£çš„å†…å­˜å—æ¥å­˜å‚¨å…ƒç´ ï¼Œæ¯ä¸ªå…ƒç´ ç”±ä¸€ä¸ªæ•°æ®åŸŸå’Œä¸€ä¸ªæŒ‡é’ˆåŸŸç»„æˆã€‚æŒ‡é’ˆåŸŸæŒ‡å‘ä¸‹ä¸€ä¸ªå…ƒç´ çš„å†…å­˜åœ°å€ï¼Œè¿™æ ·å°±å½¢æˆäº†ä¸€ä¸ªé“¾å¼ç»“æ„ã€‚

```python
"""åˆå§‹åŒ–é“¾è¡¨"""
# åˆå§‹åŒ–å„ä¸ªèŠ‚ç‚¹
n0 = ListNode(1)
n1 = ListNode(3)
n2 = ListNode(2)
n3 = ListNode(5)
n4 = ListNode(4)
# æ„å»ºèŠ‚ç‚¹ä¹‹é—´çš„å¼•ç”¨
n0.next = n1
n1.next = n2
n2.next = n3
n3.next = n4

"""æ’å…¥èŠ‚ç‚¹"""
def insert(n0: ListNode, P: ListNode):
    n1 = n0.next
    P.next = n1
    n0.next = P

"""åˆ é™¤èŠ‚ç‚¹"""
def remove(n0: ListNode):
    if not n0.next:
        return
    P = n0.next
    n1 = P.next
    n0.next = n1

"""è®¿é—®èŠ‚ç‚¹"""
def access(head: ListNode, index: int) -> ListNode | None:    
    for _ in range(index):
        if not head:
            return None
        head = head.next
    return head

"""æŸ¥æ‰¾èŠ‚ç‚¹"""
def find(head: ListNode, target: int) -> int:
    index = 0
    while head:
        if head.val == target:
            return index
        head = head.next
        index += 1
    return -1
```

##### å¸¸è§çš„é“¾è¡¨å¯åˆ†ä¸ºä»¥ä¸‹å‡ ç±»ï¼š

ï¼ˆ1ï¼‰å•é“¾è¡¨ï¼šå•é“¾è¡¨æ˜¯æœ€ç®€å•çš„é“¾è¡¨å½¢å¼ï¼Œæ¯ä¸ªèŠ‚ç‚¹åŒ…å«ä¸€ä¸ªæ•°æ®å…ƒç´ å’Œä¸€ä¸ªæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆã€‚èŠ‚ç‚¹ä¹‹é—´çš„é“¾æ¥æ˜¯å•å‘çš„ï¼Œå³ä»å¤´èŠ‚ç‚¹å¼€å§‹ï¼Œæ¯ä¸ªèŠ‚ç‚¹åªèƒ½è®¿é—®åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚

ï¼ˆ2ï¼‰åŒé“¾è¡¨ï¼šåŒå‘é“¾è¡¨åœ¨èŠ‚ç‚¹ä¸­ä¸ä»…åŒ…å«æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆï¼Œè¿˜åŒ…å«æŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆã€‚è¿™æ ·å¯ä»¥å®ç°åŒå‘éå†ï¼Œå³å¯ä»¥ä»ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹å¼€å§‹å‘å‰æˆ–å‘åéå†é“¾è¡¨ã€‚

```python
class ListNode:
    """åŒå‘é“¾è¡¨èŠ‚ç‚¹ç±»"""
    def __init__(self, val: int):
        self.val: int = val                # èŠ‚ç‚¹å€¼
        self.next: ListNode | None = None  # æŒ‡å‘åç»§èŠ‚ç‚¹çš„å¼•ç”¨
        self.prev: ListNode | None = None  # æŒ‡å‘å‰é©±èŠ‚ç‚¹çš„å¼•ç”¨
```

ï¼ˆ3ï¼‰å¾ªç¯é“¾è¡¨ï¼šå¾ªç¯é“¾è¡¨æ˜¯ä¸€ç§ç‰¹æ®Šçš„é“¾è¡¨ï¼Œå…¶ä¸­æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆæŒ‡å‘ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå½¢æˆä¸€ä¸ªå¾ªç¯ã€‚è¿™æ ·å¯ä»¥åœ¨é“¾è¡¨ä¸­å®ç°å¾ªç¯è®¿é—®ï¼Œè€Œä¸éœ€è¦ç‰¹åˆ«å¤„ç†è¾¹ç•Œæ¡ä»¶ã€‚

##### ä¾‹1.é¢ å€’é“¾è¡¨

http://dsbpython.openjudge.cn/dspythonbook/P0040/

```python
class Node:
    def __init__(self, data, next=None):
        self.data, self.next = data, next

class LinkList:
    def __init__(self, lst):
        self.head = Node(lst[0])
        p = self.head
        for i in lst[1:]:
            node = Node(i)
            p.next = node
            p = p.next

    def reverse(self): 
        prev = None
        curr = self.head
        while curr:
            next_node = curr.next
            curr.next = prev
            prev = curr
            curr = next_node
        self.head = prev
    
    def print(self):
        p = self.head
        while p:
            print(p.data, end=" ")
            p = p.next
        print()

a = list(map(int, input().split()))
a = LinkList(a)
a.reverse()
a.print()
```

##### ä¾‹2.åˆ¤æ–­æ˜¯å¦ä¸ºå›æ–‡é“¾è¡¨

æ‰¾ä¸­é—´ç‚¹åè½¬å†åˆ¤æ–­

```python
def check(head: Node) -> bool:
    slow, fast = head, head
    while fast is not None and fast.next is not None:
        fast = fast.next.next
        slow = slow.next
    prev = None
    while slow:
        tmp = slow.next
        slow.next = prev
        prev = slow
        slow = tmp
    while prev is not None:
        if head.val != prev.val:
            return False
        head = head.next
        prev = prev.next
    return True
```

### ä¸‰.æ ˆä¸é˜Ÿåˆ—

#### ï¼ˆ1ï¼‰æ ˆ

**æ ˆ**ï¼ˆstackï¼‰æ˜¯ä¸€ç§éµå¾ª**å…ˆå…¥åå‡º**é€»è¾‘çš„çº¿æ€§æ•°æ®ç»“æ„

åŸºæœ¬æ“ä½œï¼š

```python
# åˆå§‹åŒ–æ ˆ
stack: list[int] = []

# å…ƒç´ å…¥æ ˆ
stack.append(1)
stack.append(3)
stack.append(2)
stack.append(5)
stack.append(4)

# è®¿é—®æ ˆé¡¶å…ƒç´ 
peek: int = stack[-1]

# å…ƒç´ å‡ºæ ˆ
pop: int = stack.pop()

# è·å–æ ˆçš„é•¿åº¦
size: int = len(stack)

# åˆ¤æ–­æ˜¯å¦ä¸ºç©º
is_empty: bool = len(stack) == 0
```

##### æ ˆçš„å®ç°ï¼š

###### 1.åŸºäºæ•°ç»„å®ç°

ä½¿ç”¨æ•°ç»„å®ç°æ ˆæ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å°†æ•°ç»„çš„å°¾éƒ¨ä½œä¸ºæ ˆé¡¶ã€‚å…¥æ ˆä¸å‡ºæ ˆæ“ä½œåˆ†åˆ«å¯¹åº”åœ¨æ•°ç»„å°¾éƒ¨æ·»åŠ å…ƒç´ ä¸åˆ é™¤å…ƒç´ ï¼Œæ—¶é—´å¤æ‚åº¦éƒ½ä¸º ğ‘‚(1) ã€‚

```python
class ArrayStack:
    """åŸºäºæ•°ç»„å®ç°çš„æ ˆ"""
def __init__(self):
    """æ„é€ æ–¹æ³•"""
    self._stack: list[int] = []

def size(self) -> int:
    """è·å–æ ˆçš„é•¿åº¦"""
    return len(self._stack)

def is_empty(self) -> bool:
    """åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©º"""
    return self.size() == 0

def push(self, item: int):
    """å…¥æ ˆ"""
    self._stack.append(item)

def pop(self) -> int:
    """å‡ºæ ˆ"""
    if self.is_empty():
        raise IndexError("æ ˆä¸ºç©º")
    return self._stack.pop()

def peek(self) -> int:
    """è®¿é—®æ ˆé¡¶å…ƒç´ """
    if self.is_empty():
        raise IndexError("æ ˆä¸ºç©º")
    return self._stack[-1]

def to_list(self) -> list[int]:
    """è¿”å›åˆ—è¡¨ç”¨äºæ‰“å°"""
    return self._stack
```

###### 2.åŸºäºé“¾è¡¨å®ç°

ä½¿ç”¨é“¾è¡¨å®ç°æ ˆæ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å°†é“¾è¡¨çš„å¤´èŠ‚ç‚¹è§†ä¸ºæ ˆé¡¶ï¼Œå°¾èŠ‚ç‚¹è§†ä¸ºæ ˆåº•ã€‚å¯¹äºå…¥æ ˆæ“ä½œï¼Œæˆ‘ä»¬åªéœ€å°†å…ƒç´ æ’å…¥é“¾è¡¨å¤´éƒ¨ï¼Œè¿™ç§èŠ‚ç‚¹æ’å…¥æ–¹æ³•è¢«ç§°ä¸ºâ€œå¤´æ’æ³•â€ã€‚è€Œå¯¹äºå‡ºæ ˆæ“ä½œï¼Œåªéœ€å°†å¤´èŠ‚ç‚¹ä»é“¾è¡¨ä¸­åˆ é™¤å³å¯ã€‚

```python
class LinkedListStack:
    """åŸºäºé“¾è¡¨å®ç°çš„æ ˆ"""
def __init__(self):
    """æ„é€ æ–¹æ³•"""
    self._peek: ListNode | None = None
    self._size: int = 0

def size(self) -> int:
    """è·å–æ ˆçš„é•¿åº¦"""
    return self._size

def is_empty(self) -> bool:
    """åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©º"""
    return self._size == 0

def push(self, val: int):
    """å…¥æ ˆ"""
    node = ListNode(val)
    node.next = self._peek
    self._peek = node
    self._size += 1

def pop(self) -> int:
    """å‡ºæ ˆ"""
    num = self.peek()
    self._peek = self._peek.next
    self._size -= 1
    return num

def peek(self) -> int:
    """è®¿é—®æ ˆé¡¶å…ƒç´ """
    if self.is_empty():
        raise IndexError("æ ˆä¸ºç©º")
    return self._peek.val

def to_list(self) -> list[int]:
    """è½¬åŒ–ä¸ºåˆ—è¡¨ç”¨äºæ‰“å°"""
    arr = []
    node = self._peek
    while node:
        arr.append(node.val)
        node = node.next
    arr.reverse()
    return arr
```

#### ï¼ˆ2ï¼‰é˜Ÿåˆ—

**é˜Ÿåˆ—**ï¼ˆQueueï¼‰æ˜¯ä¸€ç§çº¿æ€§æ•°æ®ç»“æ„ï¼Œéµå¾ª**å…ˆè¿›å…ˆå‡º**çš„åŸåˆ™ã€‚é˜Ÿåˆ—å…è®¸åœ¨ä¸€ç«¯è¿›è¡Œæ’å…¥æ“ä½œï¼ˆé˜Ÿå°¾ï¼‰ï¼Œåœ¨å¦ä¸€ç«¯è¿›è¡Œåˆ é™¤æ“ä½œï¼ˆé˜Ÿå¤´ï¼‰ã€‚

åŸºæœ¬æ“ä½œï¼š

```python
from collections import deque
# åˆå§‹åŒ–é˜Ÿåˆ—

que: deque[int] = deque()

# å…ƒç´ å…¥é˜Ÿ
que.append(1)
que.append(3)
que.append(2)
que.append(5)
que.append(4)

# è®¿é—®é˜Ÿé¦–å…ƒç´ 
front: int = que[0]

# å…ƒç´ å‡ºé˜Ÿ
pop: int = que.popleft()

# è·å–é˜Ÿåˆ—çš„é•¿åº¦
size: int = len(que)

# åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
is_empty: bool = len(que) == 0
```

##### é˜Ÿåˆ—çš„å®ç°ï¼š

###### 1.åŸºäºæ•°ç»„çš„å®ç°

**æ•°ç»„ä¸­åŒ…å«å…ƒç´ çš„æœ‰æ•ˆåŒºé—´ä¸º `[front, rear - 1]`**ã€‚

- å…¥é˜Ÿæ“ä½œï¼šå°†è¾“å…¥å…ƒç´ èµ‹å€¼ç»™ `rear` ç´¢å¼•å¤„ï¼Œå¹¶å°† `size` å¢åŠ  1 ã€‚
- å‡ºé˜Ÿæ“ä½œï¼šåªéœ€å°† `front` å¢åŠ  1 ï¼Œå¹¶å°† `size` å‡å°‘ 1 ã€‚

è¿™æ ·ï¼Œå…¥é˜Ÿå’Œå‡ºé˜Ÿæ“ä½œéƒ½åªéœ€è¿›è¡Œä¸€æ¬¡æ“ä½œï¼Œæ—¶é—´å¤æ‚åº¦å‡ä¸º ğ‘‚(1) ã€‚

ä¸ºè§£å†³åœ¨ä¸æ–­è¿›è¡Œå…¥é˜Ÿå’Œå‡ºé˜Ÿçš„è¿‡ç¨‹ä¸­ï¼Œ`front` å’Œ `rear` éƒ½å‘å³ç§»åŠ¨ï¼Œå½“å®ƒä»¬åˆ°è¾¾æ•°ç»„å°¾éƒ¨æ—¶å°±æ— æ³•ç»§ç»­ç§»åŠ¨çš„é—®é¢˜ã€‚æˆ‘ä»¬å¯ä»¥å°†æ•°ç»„è§†ä¸ºé¦–å°¾ç›¸æ¥çš„â€œç¯å½¢æ•°ç»„â€ã€‚

```python
class ArrayQueue:
    """åŸºäºç¯å½¢æ•°ç»„å®ç°çš„é˜Ÿåˆ—"""
def __init__(self, size: int):
    """æ„é€ æ–¹æ³•"""
    self._nums: list[int] = [0] * size  # ç”¨äºå­˜å‚¨é˜Ÿåˆ—å…ƒç´ çš„æ•°ç»„
    self._front: int = 0  # é˜Ÿé¦–æŒ‡é’ˆï¼ŒæŒ‡å‘é˜Ÿé¦–å…ƒç´ 
    self._size: int = 0  # é˜Ÿåˆ—é•¿åº¦

def capacity(self) -> int:
    """è·å–é˜Ÿåˆ—çš„å®¹é‡"""
    return len(self._nums)

def size(self) -> int:
    """è·å–é˜Ÿåˆ—çš„é•¿åº¦"""
    return self._size

def is_empty(self) -> bool:
    """åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º"""
    return self._size == 0

def push(self, num: int):
    """å…¥é˜Ÿ"""
    if self._size == self.capacity():
        raise IndexError("é˜Ÿåˆ—å·²æ»¡")
    # è®¡ç®—é˜Ÿå°¾æŒ‡é’ˆï¼ŒæŒ‡å‘é˜Ÿå°¾ç´¢å¼• + 1
    # é€šè¿‡å–ä½™æ“ä½œå®ç° rear è¶Šè¿‡æ•°ç»„å°¾éƒ¨åå›åˆ°å¤´éƒ¨
    rear: int = (self._front + self._size) % self.capacity()
    # å°† num æ·»åŠ è‡³é˜Ÿå°¾
    self._nums[rear] = num
    self._size += 1

def pop(self) -> int:
    """å‡ºé˜Ÿ"""
    num: int = self.peek()
    # é˜Ÿé¦–æŒ‡é’ˆå‘åç§»åŠ¨ä¸€ä½ï¼Œè‹¥è¶Šè¿‡å°¾éƒ¨ï¼Œåˆ™è¿”å›åˆ°æ•°ç»„å¤´éƒ¨
    self._front = (self._front + 1) % self.capacity()
    self._size -= 1
    return num

def peek(self) -> int:
    """è®¿é—®é˜Ÿé¦–å…ƒç´ """
    if self.is_empty():
        raise IndexError("é˜Ÿåˆ—ä¸ºç©º")
    return self._nums[self._front]

def to_list(self) -> list[int]:
    """è¿”å›åˆ—è¡¨ç”¨äºæ‰“å°"""
    res = [0] * self.size()
    j: int = self._front
    for i in range(self.size()):
        res[i] = self._nums[(j % self.capacity())]
        j += 1
    return res
```

###### 2.åŸºäºé“¾è¡¨çš„å®ç°

æˆ‘ä»¬å¯ä»¥å°†é“¾è¡¨çš„â€œå¤´èŠ‚ç‚¹â€å’Œâ€œå°¾èŠ‚ç‚¹â€åˆ†åˆ«è§†ä¸ºâ€œé˜Ÿé¦–â€å’Œâ€œé˜Ÿå°¾â€ï¼Œè§„å®šé˜Ÿå°¾ä»…å¯æ·»åŠ èŠ‚ç‚¹ï¼Œé˜Ÿé¦–ä»…å¯åˆ é™¤èŠ‚ç‚¹ã€‚

```python
class LinkedListQueue:
    """åŸºäºé“¾è¡¨å®ç°çš„é˜Ÿåˆ—"""
def __init__(self):
    """æ„é€ æ–¹æ³•"""
    self._front: ListNode | None = None  # å¤´èŠ‚ç‚¹ front
    self._rear: ListNode | None = None  # å°¾èŠ‚ç‚¹ rear
    self._size: int = 0

def size(self) -> int:
    """è·å–é˜Ÿåˆ—çš„é•¿åº¦"""
    return self._size

def is_empty(self) -> bool:
    """åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º"""
    return self._size == 0

def push(self, num: int):
    """å…¥é˜Ÿ"""
    # åœ¨å°¾èŠ‚ç‚¹åæ·»åŠ  num
    node = ListNode(num)
    # å¦‚æœé˜Ÿåˆ—ä¸ºç©ºï¼Œåˆ™ä»¤å¤´ã€å°¾èŠ‚ç‚¹éƒ½æŒ‡å‘è¯¥èŠ‚ç‚¹
    if self._front is None:
        self._front = node
        self._rear = node
    # å¦‚æœé˜Ÿåˆ—ä¸ä¸ºç©ºï¼Œåˆ™å°†è¯¥èŠ‚ç‚¹æ·»åŠ åˆ°å°¾èŠ‚ç‚¹å
    else:
        self._rear.next = node
        self._rear = node
    self._size += 1

def pop(self) -> int:
    """å‡ºé˜Ÿ"""
    num = self.peek()
    # åˆ é™¤å¤´èŠ‚ç‚¹
    self._front = self._front.next
    self._size -= 1
    return num

def peek(self) -> int:
    """è®¿é—®é˜Ÿé¦–å…ƒç´ """
    if self.is_empty():
        raise IndexError("é˜Ÿåˆ—ä¸ºç©º")
    return self._front.val

def to_list(self) -> list[int]:
    """è½¬åŒ–ä¸ºåˆ—è¡¨ç”¨äºæ‰“å°"""
    queue = []
    temp = self._front
    while temp:
        queue.append(temp.val)
        temp = temp.next
    return queue
```

#### ï¼ˆ3ï¼‰åŒå‘é˜Ÿåˆ—

åœ¨é˜Ÿåˆ—ä¸­ï¼Œä»…èƒ½åˆ é™¤å¤´éƒ¨å…ƒç´ æˆ–åœ¨å°¾éƒ¨æ·»åŠ å…ƒç´ ã€‚**åŒå‘é˜Ÿåˆ—**ï¼ˆdouble-ended queueï¼‰æä¾›äº†æ›´é«˜çš„çµæ´»æ€§ï¼Œ**å…è®¸åœ¨å¤´éƒ¨å’Œå°¾éƒ¨æ‰§è¡Œå…ƒç´ çš„æ·»åŠ æˆ–åˆ é™¤æ“ä½œ**ã€‚

åŸºæœ¬æ“ä½œï¼š

```python
from collections import deque

# åˆå§‹åŒ–åŒå‘é˜Ÿåˆ—
deq: deque[int] = deque()

# å…ƒç´ å…¥é˜Ÿ
deq.append(2)      # æ·»åŠ è‡³é˜Ÿå°¾
deq.append(5)
deq.append(4)
deq.appendleft(3)  # æ·»åŠ è‡³é˜Ÿé¦–
deq.appendleft(1)

# è®¿é—®å…ƒç´ 
front: int = deq[0]  # é˜Ÿé¦–å…ƒç´ 
rear: int = deq[-1]  # é˜Ÿå°¾å…ƒç´ 

# å…ƒç´ å‡ºé˜Ÿ
pop_front: int = deq.popleft()  # é˜Ÿé¦–å…ƒç´ å‡ºé˜Ÿ
pop_rear: int = deq.pop()       # é˜Ÿå°¾å…ƒç´ å‡ºé˜Ÿ

# è·å–åŒå‘é˜Ÿåˆ—çš„é•¿åº¦
size: int = len(deq)

# åˆ¤æ–­åŒå‘é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
is_empty: bool = len(deq) == 0
```

##### åŒå‘é˜Ÿåˆ—çš„å®ç°ï¼š

###### 1.åŸºäºæ•°ç»„çš„å®ç°

ä½¿ç”¨ç¯å½¢æ•°ç»„æ¥å®ç°åŒå‘é˜Ÿåˆ—

```python
class ArrayDeque:
    """åŸºäºç¯å½¢æ•°ç»„å®ç°çš„åŒå‘é˜Ÿåˆ—"""
def __init__(self, capacity: int):
    """æ„é€ æ–¹æ³•"""
    self._nums: list[int] = [0] * capacity
    self._front: int = 0
    self._size: int = 0

def capacity(self) -> int:
    """è·å–åŒå‘é˜Ÿåˆ—çš„å®¹é‡"""
    return len(self._nums)

def size(self) -> int:
    """è·å–åŒå‘é˜Ÿåˆ—çš„é•¿åº¦"""
    return self._size

def is_empty(self) -> bool:
    """åˆ¤æ–­åŒå‘é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º"""
    return self._size == 0

def index(self, i: int) -> int:
    """è®¡ç®—ç¯å½¢æ•°ç»„ç´¢å¼•"""
    # é€šè¿‡å–ä½™æ“ä½œå®ç°æ•°ç»„é¦–å°¾ç›¸è¿
    # å½“ i è¶Šè¿‡æ•°ç»„å°¾éƒ¨åï¼Œå›åˆ°å¤´éƒ¨
    # å½“ i è¶Šè¿‡æ•°ç»„å¤´éƒ¨åï¼Œå›åˆ°å°¾éƒ¨
    return (i + self.capacity()) % self.capacity()

def push_first(self, num: int):
    """é˜Ÿé¦–å…¥é˜Ÿ"""
    if self._size == self.capacity():
        print("åŒå‘é˜Ÿåˆ—å·²æ»¡")
        return
    # é˜Ÿé¦–æŒ‡é’ˆå‘å·¦ç§»åŠ¨ä¸€ä½
    # é€šè¿‡å–ä½™æ“ä½œå®ç° front è¶Šè¿‡æ•°ç»„å¤´éƒ¨åå›åˆ°å°¾éƒ¨
    self._front = self.index(self._front - 1)
    # å°† num æ·»åŠ è‡³é˜Ÿé¦–
    self._nums[self._front] = num
    self._size += 1

def push_last(self, num: int):
    """é˜Ÿå°¾å…¥é˜Ÿ"""
    if self._size == self.capacity():
        print("åŒå‘é˜Ÿåˆ—å·²æ»¡")
        return
    # è®¡ç®—é˜Ÿå°¾æŒ‡é’ˆï¼ŒæŒ‡å‘é˜Ÿå°¾ç´¢å¼• + 1
    rear = self.index(self._front + self._size)
    # å°† num æ·»åŠ è‡³é˜Ÿå°¾
    self._nums[rear] = num
    self._size += 1

def pop_first(self) -> int:
    """é˜Ÿé¦–å‡ºé˜Ÿ"""
    num = self.peek_first()
    # é˜Ÿé¦–æŒ‡é’ˆå‘åç§»åŠ¨ä¸€ä½
    self._front = self.index(self._front + 1)
    self._size -= 1
    return num

def pop_last(self) -> int:
    """é˜Ÿå°¾å‡ºé˜Ÿ"""
    num = self.peek_last()
    self._size -= 1
    return num

def peek_first(self) -> int:
    """è®¿é—®é˜Ÿé¦–å…ƒç´ """
    if self.is_empty():
        raise IndexError("åŒå‘é˜Ÿåˆ—ä¸ºç©º")
    return self._nums[self._front]

def peek_last(self) -> int:
    """è®¿é—®é˜Ÿå°¾å…ƒç´ """
    if self.is_empty():
        raise IndexError("åŒå‘é˜Ÿåˆ—ä¸ºç©º")
    # è®¡ç®—å°¾å…ƒç´ ç´¢å¼•
    last = self.index(self._front + self._size - 1)
    return self._nums[last]

def to_array(self) -> list[int]:
    """è¿”å›æ•°ç»„ç”¨äºæ‰“å°"""
    # ä»…è½¬æ¢æœ‰æ•ˆé•¿åº¦èŒƒå›´å†…çš„åˆ—è¡¨å…ƒç´ 
    res = []
    for i in range(self._size):
        res.append(self._nums[self.index(self._front + i)])
    return res
```

###### 2.åŸºäºåŒå‘é“¾è¡¨çš„å®ç°

```python
class ListNode:
    """åŒå‘é“¾è¡¨èŠ‚ç‚¹"""
def __init__(self, val: int):
    """æ„é€ æ–¹æ³•"""
    self.val: int = val
    self.next: ListNode | None = None  # åç»§èŠ‚ç‚¹å¼•ç”¨
    self.prev: ListNode | None = None  # å‰é©±èŠ‚ç‚¹å¼•ç”¨
class LinkedListDeque:
    """åŸºäºåŒå‘é“¾è¡¨å®ç°çš„åŒå‘é˜Ÿåˆ—"""
def __init__(self):
    """æ„é€ æ–¹æ³•"""
    self._front: ListNode | None = None  # å¤´èŠ‚ç‚¹ front
    self._rear: ListNode | None = None  # å°¾èŠ‚ç‚¹ rear
    self._size: int = 0  # åŒå‘é˜Ÿåˆ—çš„é•¿åº¦

def size(self) -> int:
    """è·å–åŒå‘é˜Ÿåˆ—çš„é•¿åº¦"""
    return self._size

def is_empty(self) -> bool:
    """åˆ¤æ–­åŒå‘é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º"""
    return self._size == 0

def push(self, num: int, is_front: bool):
    """å…¥é˜Ÿæ“ä½œ"""
    node = ListNode(num)
    # è‹¥é“¾è¡¨ä¸ºç©ºï¼Œåˆ™ä»¤ front å’Œ rear éƒ½æŒ‡å‘ node
    if self.is_empty():
        self._front = self._rear = node
    # é˜Ÿé¦–å…¥é˜Ÿæ“ä½œ
    elif is_front:
        # å°† node æ·»åŠ è‡³é“¾è¡¨å¤´éƒ¨
        self._front.prev = node
        node.next = self._front
        self._front = node  # æ›´æ–°å¤´èŠ‚ç‚¹
    # é˜Ÿå°¾å…¥é˜Ÿæ“ä½œ
    else:
        # å°† node æ·»åŠ è‡³é“¾è¡¨å°¾éƒ¨
        self._rear.next = node
        node.prev = self._rear
        self._rear = node  # æ›´æ–°å°¾èŠ‚ç‚¹
    self._size += 1  # æ›´æ–°é˜Ÿåˆ—é•¿åº¦

def push_first(self, num: int):
    """é˜Ÿé¦–å…¥é˜Ÿ"""
    self.push(num, True)

def push_last(self, num: int):
    """é˜Ÿå°¾å…¥é˜Ÿ"""
    self.push(num, False)

def pop(self, is_front: bool) -> int:
    """å‡ºé˜Ÿæ“ä½œ"""
    if self.is_empty():
        raise IndexError("åŒå‘é˜Ÿåˆ—ä¸ºç©º")
    # é˜Ÿé¦–å‡ºé˜Ÿæ“ä½œ
    if is_front:
        val: int = self._front.val  # æš‚å­˜å¤´èŠ‚ç‚¹å€¼
        # åˆ é™¤å¤´èŠ‚ç‚¹
        fnext: ListNode | None = self._front.next
        if fnext != None:
            fnext.prev = None
            self._front.next = None
        self._front = fnext  # æ›´æ–°å¤´èŠ‚ç‚¹
    # é˜Ÿå°¾å‡ºé˜Ÿæ“ä½œ
    else:
        val: int = self._rear.val  # æš‚å­˜å°¾èŠ‚ç‚¹å€¼
        # åˆ é™¤å°¾èŠ‚ç‚¹
        rprev: ListNode | None = self._rear.prev
        if rprev != None:
            rprev.next = None
            self._rear.prev = None
        self._rear = rprev  # æ›´æ–°å°¾èŠ‚ç‚¹
    self._size -= 1  # æ›´æ–°é˜Ÿåˆ—é•¿åº¦
    return val

def pop_first(self) -> int:
    """é˜Ÿé¦–å‡ºé˜Ÿ"""
    return self.pop(True)

def pop_last(self) -> int:
    """é˜Ÿå°¾å‡ºé˜Ÿ"""
    return self.pop(False)

def peek_first(self) -> int:
    """è®¿é—®é˜Ÿé¦–å…ƒç´ """
    if self.is_empty():
        raise IndexError("åŒå‘é˜Ÿåˆ—ä¸ºç©º")
    return self._front.val

def peek_last(self) -> int:
    """è®¿é—®é˜Ÿå°¾å…ƒç´ """
    if self.is_empty():
        raise IndexError("åŒå‘é˜Ÿåˆ—ä¸ºç©º")
    return self._rear.val

def to_array(self) -> list[int]:
    """è¿”å›æ•°ç»„ç”¨äºæ‰“å°"""
    node = self._front
    res = [0] * self.size()
    for i in range(self.size()):
        res[i] = node.val
        node = node.next
    return res
```

##### ä¾‹3.ä¸­åºè¡¨è¾¾å¼è½¬ååºè¡¨è¾¾å¼

##### http://cs101.openjudge.cn/practice/24591/

```python
def infix_to_postfix(expression):
    precedence = {'+':1, '-':1, '*':2, '/':2}
    stack = []
    postfix = []
    number = ''

    for char in expression:
        if char.isnumeric() or char == '.':
            number += char
        else:
            if number:
                num = float(number)
                postfix.append(int(num) if num.is_integer() else num)
                number = ''
            if char in '+-*/':
                while stack and stack[-1] in '+-*/' and precedence[char] <= precedence[stack[-1]]:
                    postfix.append(stack.pop())
                stack.append(char)
            elif char == '(':
                stack.append(char)
            elif char == ')':
                while stack and stack[-1] != '(':
                    postfix.append(stack.pop())
                stack.pop()
    
    if number:
        num = float(number)
        postfix.append(int(num) if num.is_integer() else num)
    
    while stack:
        postfix.append(stack.pop())
    
    return ' '.join(str(x) for x in postfix)

n = int(input())
for _ in range(n):
    expression = input()
    print(infix_to_postfix(expression))
```

##### ä¾‹4.å…«çš‡åé—®é¢˜ï¼ˆç”¨æ ˆå®ç°ï¼‰

http://cs101.openjudge.cn/practice/02754

```python
def queen_stack(n):
    stack = []  # ç”¨äºä¿å­˜çŠ¶æ€çš„æ ˆ
    solutions = [] # å­˜å‚¨æ‰€æœ‰è§£å†³æ–¹æ¡ˆçš„åˆ—è¡¨

    stack.append((0, []))  # åˆå§‹çŠ¶æ€ä¸ºç¬¬ä¸€è¡Œï¼Œæ‰€æœ‰åˆ—éƒ½æœªæ”¾ç½®çš‡å,æ ˆä¸­çš„å…ƒç´ æ˜¯ (row, queens) çš„å…ƒç»„
    
    while stack:
        row, cols = stack.pop() # ä»æ ˆä¸­å–å‡ºå½“å‰å¤„ç†çš„è¡Œæ•°å’Œå·²æ”¾ç½®çš„çš‡åä½ç½®
        if row == n:    # æ‰¾åˆ°ä¸€ä¸ªåˆæ³•è§£å†³æ–¹æ¡ˆ
            solutions.append(cols)
        else:
            for col in range(n):
                if is_valid(row, col, cols): # æ£€æŸ¥å½“å‰ä½ç½®æ˜¯å¦åˆæ³•
                    stack.append((row + 1, cols + [col]))   
    return solutions

def is_valid(row, col, queens):
    for r in range(row):
        if queens[r] == col or abs(row - r) == abs(col - queens[r]):
            return False
    return True

# è·å–ç¬¬ b ä¸ªçš‡åä¸²
def get_queen_string(b):
    solutions = queen_stack(8)
    if b > len(solutions):
        return None
    b = len(solutions) + 1 - b
    queen_string = ''.join(str(col + 1) for col in solutions[b - 1])
    return queen_string

test_cases = int(input())  # è¾“å…¥çš„æµ‹è¯•æ•°æ®ç»„æ•°
for _ in range(test_cases):
    b = int(input())  # è¾“å…¥çš„ b å€¼
    queen_string = get_queen_string(b)
    print(queen_string)
```

##### ä¾‹5.çº¦ç‘Ÿå¤«é—®é¢˜

http://cs101.openjudge.cn/practice/02746

â‘ ç”¨listå®ç°é˜Ÿåˆ—ï¼ŒO(n)

```python
# å…ˆä½¿ç”¨popä»åˆ—è¡¨ä¸­å–å‡ºï¼Œå¦‚æœä¸ç¬¦åˆè¦æ±‚å†appendå›åˆ—è¡¨ï¼Œç›¸å½“äºæ„æˆäº†ä¸€ä¸ªåœˆ
def hot_potato(name_list, num):
    queue = []
    for name in name_list:
        queue.append(name)

    while len(queue) > 1:
        for i in range(num):
            queue.append(queue.pop(0))	# O(N)
        queue.pop(0)										# O(N)
    return queue.pop(0)									# O(N)

while True:
    n, m = map(int, input().split())
    if {n,m} == {0}:
        break
    monkey = [i for i in range(1, n+1)]
    print(hot_potato(monkey, m-1))
```

â‘¡ç”¨å†…ç½®dequeï¼ŒO(1)

```python
from collections import deque

# å…ˆä½¿ç”¨popä»åˆ—è¡¨ä¸­å–å‡ºï¼Œå¦‚æœä¸ç¬¦åˆè¦æ±‚å†appendå›åˆ—è¡¨ï¼Œç›¸å½“äºæ„æˆäº†ä¸€ä¸ªåœˆ
def hot_potato(name_list, num):
    queue = deque()
    for name in name_list:
        queue.append(name)

    while len(queue) > 1:
        for i in range(num):
            queue.append(queue.popleft()) # O(1)
        queue.popleft()
    return queue.popleft()

while True:
    n, m = map(int, input().split())
    if {n,m} == {0}:
        break
    monkey = [i for i in range(1, n+1)]
    print(hot_potato(monkey, m-1))
```

### å››.æ ‘

#### ï¼ˆ1ï¼‰æ ‘çš„æ¦‚å¿µå’Œè¡¨ç¤ºæ–¹æ³•

æ ‘ç”±**èŠ‚ç‚¹åŠè¿æ¥èŠ‚ç‚¹çš„è¾¹**æ„æˆï¼Œæœ‰å¦‚ä¸‹æ€§è´¨ï¼š

###### 1.æœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼›

###### 2.â€‹é™¤æ ¹èŠ‚ç‚¹å¤–ï¼Œå…¶ä»–æ¯ä¸ªèŠ‚ç‚¹éƒ½ä¸å…¶å”¯ä¸€çš„çˆ¶èŠ‚ç‚¹ç›¸è¿ï¼›

###### 3.ä»æ ¹èŠ‚ç‚¹åˆ°å…¶ä»–æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸”ä»…æœ‰ä¸€æ¡è·¯å¾„ï¼›

**äºŒå‰æ ‘**ï¼šæ¯ä¸ªèŠ‚ç‚¹æœ€å¤šæœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹

æŒ‰å½¢æ€åˆ†ç±»:

ï¼ˆ1ï¼‰å®Œå…¨äºŒå‰æ ‘â€”â€”ç¬¬n-1å±‚å…¨æ»¡ï¼Œæœ€åä¸€å±‚æŒ‰é¡ºåºæ’åˆ—ï¼ˆé å·¦ï¼‰

ï¼ˆ2ï¼‰æ»¡äºŒå‰æ ‘â€”â€”äºŒå‰æ ‘çš„æœ€ä¸‹é¢ä¸€å±‚å…ƒç´ å…¨éƒ¨æ»¡å°±æ˜¯æ»¡äºŒå‰æ ‘

ï¼ˆ3ï¼‰avlæ ‘â€”â€”å·¦å³å­æ ‘é«˜åº¦å·®ä¸è¶…è¿‡1

ï¼ˆ4ï¼‰äºŒå‰æŸ¥æ‰¾æ ‘(äºŒå‰æ’åº\æœç´¢æ ‘)â€”â€”å·¦<ä¸­<å³

##### ä¾‹6.äºŒå‰æ ‘çš„æ·±åº¦

http://cs101.openjudge.cn/practice/06646/

```python
class TreeNode:
    def __init__(self):
        self.left = None
        self.right = None

def tree_depth(node):
    if node is None:
        return 0
    left_depth = tree_depth(node.left)
    right_depth = tree_depth(node.right)
    return max(left_depth, right_depth) + 1

n = int(input())  # è¯»å–èŠ‚ç‚¹æ•°é‡
nodes = [TreeNode() for _ in range(n)]

for i in range(n):
    left_index, right_index = map(int, input().split())
    if left_index != -1:
        nodes[i].left = nodes[left_index-1]
    if right_index != -1:
        nodes[i].right = nodes[right_index-1]

root = nodes[0]
depth = tree_depth(root)
print(depth)
```

##### ä¾‹7.æ±‚äºŒå‰æ ‘çš„é«˜åº¦å’Œå¶å­æ•°ç›®

http://cs101.openjudge.cn/practice/27638/

```python
class TreeNode:
    def __init__(self):
        self.left = None
        self.right = None

def tree_height(node):
    if node is None:
        return -1  # æ ¹æ®å®šä¹‰ï¼Œç©ºæ ‘é«˜åº¦ä¸º-1
    return max(tree_height(node.left), tree_height(node.right)) + 1

def count_leaves(node):
    if node is None:
        return 0
    if node.left is None and node.right is None:
        return 1
    return count_leaves(node.left) + count_leaves(node.right)

n = int(input())  # è¯»å–èŠ‚ç‚¹æ•°é‡
nodes = [TreeNode() for _ in range(n)]
has_parent = [False] * n  # ç”¨æ¥æ ‡è®°èŠ‚ç‚¹æ˜¯å¦æœ‰çˆ¶èŠ‚ç‚¹

for i in range(n):
    left_index, right_index = map(int, input().split())
    if left_index != -1:
        nodes[i].left = nodes[left_index]
        has_parent[left_index] = True
    if right_index != -1:
        #print(right_index)
        nodes[i].right = nodes[right_index]
        has_parent[right_index] = True

# å¯»æ‰¾æ ¹èŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰çˆ¶èŠ‚ç‚¹çš„èŠ‚ç‚¹

root_index = has_parent.index(False)
root = nodes[root_index]

# è®¡ç®—é«˜åº¦å’Œå¶å­èŠ‚ç‚¹æ•°

height = tree_height(root)
leaves = count_leaves(root)

print(f"{height} {leaves}")
```

#### ï¼ˆ2ï¼‰æ ‘çš„åŸºæœ¬æ“ä½œ

**è§£ææ ‘çš„æ„å»ºï¼š**

```python
class Stack(object):
        def __init__(self):
            self.items = []
            self.stack_size = 0
    def isEmpty(self):
        return self.stack_size == 0
    
    def push(self, new_item):
        self.items.append(new_item)
        self.stack_size += 1
    
    def pop(self):
        self.stack_size -= 1
        return self.items.pop()
    
    def peek(self):
        return self.items[self.stack_size - 1]
    
    def size(self):
        return self.stack_size

class BinaryTree:
    def __init__(self, rootObj):
        self.key = rootObj
        self.leftChild = None
        self.rightChild = None
def insertLeft(self, newNode):
    if self.leftChild == None:
        self.leftChild = BinaryTree(newNode)
    else:  # å·²ç»å­˜åœ¨å·¦å­èŠ‚ç‚¹ã€‚æ­¤æ—¶ï¼Œæ’å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¹¶å°†å·²æœ‰çš„å·¦å­èŠ‚ç‚¹é™ä¸€å±‚ã€‚
        t = BinaryTree(newNode)
        t.leftChild = self.leftChild
        self.leftChild = t

def insertRight(self, newNode):
    if self.rightChild == None:
        self.rightChild = BinaryTree(newNode)
    else:
        t = BinaryTree(newNode)
        t.rightChild = self.rightChild
        self.rightChild = t

def getRightChild(self):
    return self.rightChild

def getLeftChild(self):
    return self.leftChild

def setRootVal(self, obj):
    self.key = obj

def getRootVal(self):
    return self.key

def traversal(self, method="preorder"):
    if method == "preorder":
        print(self.key, end=" ")
    if self.leftChild != None:
        self.leftChild.traversal(method)
    if method == "inorder":
        print(self.key, end=" ")
    if self.rightChild != None:
        self.rightChild.traversal(method)
    if method == "postorder":
        print(self.key, end=" ")
def buildParseTree(fpexp):
    fplist = fpexp.split()
    pStack = Stack()
    eTree = BinaryTree('')
    pStack.push(eTree)
    currentTree = eTree
for i in fplist:
    if i == '(':
        currentTree.insertLeft('')
        pStack.push(currentTree)
        currentTree = currentTree.getLeftChild()
    elif i not in '+-*/)':
        currentTree.setRootVal(int(i))
        parent = pStack.pop()
        currentTree = parent
    elif i in '+-*/':
        currentTree.setRootVal(i)
        currentTree.insertRight('')
        pStack.push(currentTree)
        currentTree = currentTree.getRightChild()
    elif i == ')':
        currentTree = pStack.pop()
    else:
        raise ValueError("Unknown Operator: " + i)
return eTree
```




##### ä¾‹8.æ ¹æ®ååºè¡¨è¾¾å¼å»ºç«‹é˜Ÿåˆ—è¡¨è¾¾å¼

http://cs101.openjudge.cn/practice/25140/

```python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def build_tree(postfix):
    stack = []
    for char in postfix:
        node = TreeNode(char)
        if char.isupper():
            node.right = stack.pop()
            node.left = stack.pop()
        stack.append(node)
    return stack[0]

def level_order_traversal(root):
    queue = [root]
    traversal = []
    while queue:
        node = queue.pop(0)
        traversal.append(node.value)
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    return traversal

n = int(input().strip())
for _ in range(n):
    postfix = input().strip()
    root = build_tree(postfix)
    queue_expression = level_order_traversal(root)[::-1]
    print(''.join(queue_expression))
```

##### ä¾‹9.æ ¹æ®äºŒå‰æ ‘ä¸­ååºåºåˆ—å»ºæ ‘

http://cs101.openjudge.cn/practice/24750/

```python
"""
ååºéå†çš„æœ€åä¸€ä¸ªå…ƒç´ æ˜¯æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚ç„¶åï¼Œåœ¨ä¸­åºéå†åºåˆ—ä¸­ï¼Œæ ¹èŠ‚ç‚¹å°†å·¦å³å­æ ‘åˆ†å¼€ã€‚
å¯ä»¥é€šè¿‡è¿™ç§æ–¹æ³•æ‰¾åˆ°å·¦å³å­æ ‘çš„ä¸­åºéå†åºåˆ—ã€‚ç„¶åï¼Œä½¿ç”¨é€’å½’åœ°å¤„ç†å·¦å³å­æ ‘æ¥æ„å»ºæ•´ä¸ªæ ‘ã€‚
"""

def build_tree(inorder, postorder):
    if not inorder or not postorder:
        return []
    root_val = postorder[-1]
    root_index = inorder.index(root_val)
    
    left_inorder = inorder[:root_index]
    right_inorder = inorder[root_index + 1:]
    
    left_postorder = postorder[:len(left_inorder)]
    right_postorder = postorder[len(left_inorder):-1]
    
    root = [root_val]
    root.extend(build_tree(left_inorder, left_postorder))
    root.extend(build_tree(right_inorder, right_postorder))
    
    return root

def main():
    inorder = input().strip()
    postorder = input().strip()
    preorder = build_tree(inorder, postorder)
    print(''.join(preorder))

if __name__ == "__main__":
    main()
```

##### ä¾‹10.æ ¹æ®äºŒå‰æ ‘å‰ä¸­åºåºåˆ—å»ºæ ‘

http://cs101.openjudge.cn/practice/22158/

```python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def build_tree(preorder, inorder):
    if not preorder or not inorder:
        return None
    root_value = preorder[0]
    root = TreeNode(root_value)
    root_index_inorder = inorder.index(root_value)
    root.left = build_tree(preorder[1:1+root_index_inorder], inorder[:root_index_inorder])
    root.right = build_tree(preorder[1+root_index_inorder:], inorder[root_index_inorder+1:])
    return root

def postorder_traversal(root):
    if root is None:
        return ''
    return postorder_traversal(root.left) + postorder_traversal(root.right) + root.value

while True:
    try:
        preorder = input().strip()
        inorder = input().strip()
        root = build_tree(preorder, inorder)
        print(postorder_traversal(root))
    except EOFError:
        break
```

#### ï¼ˆ3ï¼‰å“ˆå¤«æ›¼ç¼–ç æ ‘

http://cs101.openjudge.cn/practice/22161/

è‡ªä¸‹å‘ä¸Šå»ºæ ‘ï¼Œé€æ¸å‘ä¸Šæ‹¼å‡‘å‡ºä¸€æ£µå®Œæ•´çš„æ ‘

```python
import heapq

class Node:
    def __init__(self, weight, char=None):
        self.weight = weight
        self.char = char
        self.left = None
        self.right = None

    def __lt__(self, other):
        if self.weight == other.weight:
            return self.char < other.char
        return self.weight < other.weight

def build_huffman_tree(characters):
    heap = []
    for char, weight in characters.items():
        heapq.heappush(heap, Node(weight, char))

    while len(heap) > 1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)
        merged = Node(left.weight + right.weight, min(left.char, right.char))
        merged.left = left
        merged.right = right
        heapq.heappush(heap, merged)
    
    return heap[0]

def encode_huffman_tree(root):
    codes = {}

    def traverse(node, code):
        if node.left is None and node.right is None:
            codes[node.char] = code
        else:
            traverse(node.left, code + '0')
            traverse(node.right, code + '1')
    
    traverse(root, '')
    return codes

def huffman_encoding(codes, string):
    encoded = ''
    for char in string:
        encoded += codes[char]
    return encoded

def huffman_decoding(root, encoded_string):
    decoded = ''
    node = root
    for bit in encoded_string:
        if bit == '0':
            node = node.left
        else:
            node = node.right

        if node.left is None and node.right is None:
            decoded += node.char
            node = root
    return decoded

# è¯»å–è¾“å…¥
n = int(input())
characters = {}
for _ in range(n):
    char, weight = input().split()
    characters[char] = int(weight)

# æ„å»ºå“ˆå¤«æ›¼ç¼–ç æ ‘
huffman_tree = build_huffman_tree(characters)

# ç¼–ç å’Œè§£ç 
codes = encode_huffman_tree(huffman_tree)

strings = []
while True:
    try:
        line = input()
        strings.append(line)

    except EOFError:
        break

results = []
for string in strings:
    if string[0] in ('0','1'):
        results.append(huffman_decoding(huffman_tree, string))
    else:
        results.append(huffman_encoding(codes, string))

for result in results:
    print(result)
```

#### ï¼ˆ4ï¼‰äºŒå‰å †

äºŒå‰å †æ˜¯ä¸€ç§ç‰¹æ®Šçš„äºŒå‰æ ‘ç»“æ„ï¼Œå®ƒæ»¡è¶³ä»¥ä¸‹ä¸¤ä¸ªæ€§è´¨ï¼š

1. **å †åºæ€§è´¨**ï¼šå¯¹äºæ¯ä¸ªèŠ‚ç‚¹Xï¼Œå®ƒçš„çˆ¶èŠ‚ç‚¹çš„å€¼è¦ä¹ˆå°äºç­‰äºXçš„å€¼ï¼ˆæœ€å°å †ï¼‰ï¼Œè¦ä¹ˆå¤§äºç­‰äºXçš„å€¼ï¼ˆæœ€å¤§å †ï¼‰ã€‚
2. **å®Œå…¨äºŒå‰æ ‘æ€§è´¨**ï¼šé™¤äº†æœ€åº•å±‚ä¹‹å¤–ï¼Œå…¶ä»–å±‚çš„èŠ‚ç‚¹æ•°å¿…é¡»è¾¾åˆ°æœ€å¤§ï¼Œå¹¶ä¸”æœ€åº•å±‚çš„èŠ‚ç‚¹éƒ½ä¾æ¬¡ä»å·¦åˆ°å³æ’åˆ—ã€‚

ç®€å•æœ€å°å †ç¤ºä¾‹ï¼š

```python
class MinHeap:
    def __init__(self):
        self.heap = []
def parent(self, i):
    return i // 2

def left_child(self, i):
    return 2 * i

def right_child(self, i):
    return 2 * i + 1

def insert(self, value):
    self.heap.append(value)
    self.heapify_up(len(self.heap) - 1)

def heapify_up(self, i):
    while i > 0 and self.heap[i] < self.heap[self.parent(i)]:
        self.heap[i], self.heap[self.parent(i)] = self.heap[self.parent(i)], self.heap[i]
        i = self.parent(i)

def extract_min(self):
    if len(self.heap) == 0:
        return None
    elif len(self.heap) == 1:
        return self.heap.pop()
    else:
        min_value = self.heap[0]
        self.heap[0] = self.heap.pop()
        self.heapify_down(0)
        return min_value

def heapify_down(self, i):
    while (left := self.left_child(i)) < len(self.heap):
        smallest = left
        right = self.right_child(i)
        if right < len(self.heap) and self.heap[right] < self.heap[left]:
            smallest = right
        if self.heap[i] <= self.heap[smallest]:
            break
        self.heap[i], self.heap[smallest] = self.heap[smallest], self.heap[i]
        i = smallest
```



##### ä¾‹11.å‘ä¸‹è°ƒæ•´æ„å»ºå¤§é¡¶å †

https://sunnywhy.com/sfbj/9/7

```python
class BinHeap:
    def __init__(self):
        self.heapList = [0]
        self.currentSize = 0

    def percUp(self, i):
        while i // 2 > 0:
            if self.heapList[i] < self.heapList[i // 2]:
                tmp = self.heapList[i // 2]
                self.heapList[i // 2] = self.heapList[i]
                self.heapList[i] = tmp
            i = i // 2
    
    def insert(self, k):
        self.heapList.append(k)
        self.currentSize = self.currentSize + 1
        self.percUp(self.currentSize)
    
    def percDown(self, i):
        while (i * 2) <= self.currentSize:
            mc = self.minChild(i)
            if self.heapList[i] > self.heapList[mc]:
                tmp = self.heapList[i]
                self.heapList[i] = self.heapList[mc]
                self.heapList[mc] = tmp
            i = mc
    
    def minChild(self, i):
        if i * 2 + 1 > self.currentSize:
            return i * 2
        else:
            if self.heapList[i * 2] < self.heapList[i * 2 + 1]:
                return i * 2
            else:
                return i * 2 + 1
    
    def delMin(self):
        retval = self.heapList[1]
        self.heapList[1] = self.heapList[self.currentSize]
        self.currentSize = self.currentSize - 1
        self.heapList.pop()
        self.percDown(1)
        return retval
    
    def buildHeap(self, alist):
        i = len(alist) // 2
        self.currentSize = len(alist)
        self.heapList = [0] + alist[:]
        while (i > 0):
            #print(f'i = {i}, {self.heapList}')
            self.percDown(i)
            i = i - 1
        #print(f'i = {i}, {self.heapList}')


n = int(input().strip())
heap = list(map(int, input().strip().split())) # [9, 5, 6, 2, 3]
heap = [-x for x in heap]

bh = BinHeap()
bh.buildHeap(heap)
ans = [-x for x in bh.heapList[1:]]
print(*ans)
```



#### ï¼ˆ5ï¼‰äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰

ç”±äºäºŒå‰æœç´¢æ ‘çš„æœ‰åºæ€§ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®ƒæ¥è¿›è¡Œé«˜æ•ˆçš„æŸ¥æ‰¾ã€æ’å…¥å’Œåˆ é™¤æ“ä½œã€‚åœ¨äºŒå‰æœç´¢æ ‘ä¸­ï¼ŒæŸ¥è¯¢ç‰¹å®šå€¼çš„æ—¶é—´å¤æ‚åº¦æ˜¯**O(logN)**ï¼Œå…¶ä¸­Næ˜¯æ ‘ä¸­èŠ‚ç‚¹çš„æ•°é‡ã€‚

ç®€å•çš„äºŒå‰æœç´¢æ ‘å®ç°ç¤ºä¾‹ï¼š

```python
class BinarySearchTreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

class BinarySearchTree:
    def __init__(self):
        self.root = None
def insert(self, value):
    if self.root is None:
        self.root = BinarySearchTreeNode(value)
    else:
        self._insert(self.root, value)

def _insert(self, node, value):
    if value < node.value:
        if node.left is None:
            node.left = BinarySearchTreeNode(value)
        else:
            self._insert(node.left, value)
    else:
        if node.right is None:
            node.right = BinarySearchTreeNode(value)
        else:
            self._insert(node.right, value)

def search(self, value):
    return self._search(self.root, value)

def _search(self, node, value):
    if node is None or node.value == value:
        return node
    if value < node.value:
        return self._search(node.left, value)
    else:
        return self._search(node.right, value)

def delete(self, value):
    self.root = self._delete(self.root, value)

def _delete(self, node, value):
    if node is None:
        return node
    if value < node.value:
        node.left = self._delete(node.left, value)
    elif value > node.value:
        node.right = self._delete(node.right, value)
    else:
        if node.left is None:
            return node.right
        elif node.right is None:
            return node.left
        else:
            min_node = self._find_min(node.right)
            node.value = min_node.value
            node.right = self._delete(node.right, min_node.value)
    return node

def _find_min(self, node):
    current = node
    while current.left is not None:
        current = current.left
    return current
```



##### ä¾‹12.äºŒå‰æœç´¢æ ‘çš„éå†

http://cs101.openjudge.cn/practice/22275/

```python
class Node():
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

def buildTree(preorder):
    if len(preorder) == 0:
        return None

    node = Node(preorder[0])
    
    idx = len(preorder)
    for i in range(1, len(preorder)):
        if preorder[i] > preorder[0]:
            idx = i
            break
    node.left = buildTree(preorder[1:idx])
    node.right = buildTree(preorder[idx:])
    
    return node

def postorder(node):
    if node is None:
        return []
    output = []
    output.extend(postorder(node.left))
    output.extend(postorder(node.right))
    output.append(str(node.val))

    return output

n = int(input())
preorder = list(map(int, input().split()))
print(' '.join(postorder(buildTree(preorder))))
```



##### ä¾‹13.äºŒå‰æœç´¢æ ‘çš„å±‚æ¬¡éå†

http://cs101.openjudge.cn/practice/05455/

```python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def insert(node, value):
    if node is None:
        return TreeNode(value)
    if value < node.value:
        node.left = insert(node.left, value)
    elif value > node.value:
        node.right = insert(node.right, value)
    return node

def level_order_traversal(root):
    queue = [root]
    traversal = []
    while queue:
        node = queue.pop(0)
        traversal.append(node.value)
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    return traversal

numbers = list(map(int, input().strip().split()))
numbers = list(dict.fromkeys(numbers)) 
root = None
for number in numbers:
    root = insert(root, number)
traversal = level_order_traversal(root)
print(' '.join(map(str, traversal)))
```

#### ï¼ˆ5ï¼‰AVLæ ‘ï¼ˆå¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼‰

AVLæ ‘æ˜¯ä¸€ç§**è‡ªå¹³è¡¡çš„äºŒå‰æœç´¢æ ‘**ï¼Œå®ƒåœ¨æ¯æ¬¡æ’å…¥æˆ–åˆ é™¤èŠ‚ç‚¹æ—¶ï¼Œä¼šé€šè¿‡æ—‹è½¬æ“ä½œæ¥ä¿æŒæ ‘çš„å¹³è¡¡ã€‚

AVLæ ‘å…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

â‘ **å¹³è¡¡å› å­**ï¼šAVLæ ‘ä¸­æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªå¹³è¡¡å› å­ï¼Œå®ƒè¡¨ç¤ºèŠ‚ç‚¹çš„å·¦å­æ ‘é«˜åº¦å‡å»å³å­æ ‘é«˜åº¦çš„å€¼ã€‚å¹³è¡¡å› å­å¯ä»¥æ˜¯-1ã€0æˆ–1ã€‚

â‘¡**å¹³è¡¡æ€§**ï¼šåœ¨AVLæ ‘ä¸­ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„å¹³è¡¡å› å­å¿…é¡»æ»¡è¶³å¹³è¡¡æ€§è¦æ±‚ï¼Œå³å¹³è¡¡å› å­çš„ç»å¯¹å€¼ä¸èƒ½è¶…è¿‡1ã€‚

â‘¢**è‡ªå¹³è¡¡æ“ä½œ**ï¼šå½“æ’å…¥æˆ–åˆ é™¤èŠ‚ç‚¹å¯¼è‡´AVLæ ‘å¤±å»å¹³è¡¡æ—¶ï¼Œéœ€è¦è¿›è¡Œè‡ªå¹³è¡¡æ“ä½œæ¥æ¢å¤å¹³è¡¡ã€‚è‡ªå¹³è¡¡æ“ä½œé€šè¿‡æ—‹è½¬èŠ‚ç‚¹å’Œæ›´æ–°å¹³è¡¡å› å­æ¥å®Œæˆã€‚



ç®€å•çš„AVLæ ‘ç”Ÿæˆç¤ºä¾‹ï¼š

```python
class AVLNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
        self.height = 1

class AVLTree:
    def __init__(self):
        self.root = None
def insert(self, value):
    self.root = self._insert(self.root, value)

def _insert(self, node, value):
    if node is None:
        return AVLNode(value)
if value < node.value:
    node.left = self._insert(node.left, value)
else:
    node.right = self._insert(node.right, value)

node.height = 1 + max(self._get_height(node.left), self._get_height(node.right))
balance_factor = self._get_balance_factor(node)

# Left Left Case
if balance_factor > 1 and value < node.left.value:
    return self._right_rotate(node)

# Right Right Case
if balance_factor < -1 and value > node.right.value:
    return self._left_rotate(node)

# Left Right Case
if balance_factor > 1 and value > node.left.value:
    node.left = self._left_rotate(node.left)
    return self._right_rotate(node)

# Right Left Case
if balance_factor < -1 and value < node.right.value:
    node.right = self._right_rotate(node.right)
    return self._left_rotate(node)

return node
def _get_height(self, node):
    if node is None:
        return 0
    return node.height

def _get_balance_factor(self, node):
    if node is None:
        return 0
    return self._get_height(node.left) - self._get_height(node.right)

def _left_rotate(self, z):
    y = z.right
    T2 = y.left
y.left = z
z.right = T2

z.height = 1 + max(self._get_height(z.left), self._get_height(z.right))
y.height = 1 + max(self._get_height(y.left), self._get_height(y.right))

return y
def _right_rotate(self, z):
    y = z.left
    T3 = y.right
y.right = z
z.left = T3

z.height = 1 + max(self._get_height(z.left), self._get_height(z.right))
y.height = 1 + max(self._get_height(y.left), self._get_height(y.right))

return y
```



##### ä¾‹14.å¹³è¡¡äºŒå‰æ ‘çš„å»ºç«‹

https://sunnywhy.com/sfbj/9/5/359

```python
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
        self.height = 1

class AVL:
    def __init__(self):
        self.root = None
def insert(self, value):
    if not self.root:
        self.root = Node(value)
    else:
        self.root = self._insert(value, self.root)

def _insert(self, value, node):
    if not node:
        return Node(value)
    elif value < node.value:
        node.left = self._insert(value, node.left)
    else:
        node.right = self._insert(value, node.right)

    node.height = 1 + max(self._get_height(node.left), self._get_height(node.right))

    balance = self._get_balance(node)

    if balance > 1:
        if value < node.left.value:	# æ ‘å½¢æ˜¯ LL
            return self._rotate_right(node)
        else:	# æ ‘å½¢æ˜¯ LR
            node.left = self._rotate_left(node.left)
            return self._rotate_right(node)

    if balance < -1:
        if value > node.right.value:	# æ ‘å½¢æ˜¯ RR
            return self._rotate_left(node)
        else:	# æ ‘å½¢æ˜¯ RL
            node.right = self._rotate_right(node.right)
            return self._rotate_left(node)

    return node

def _get_height(self, node):
    if not node:
        return 0
    return node.height

def _get_balance(self, node):
    if not node:
        return 0
    return self._get_height(node.left) - self._get_height(node.right)

def _rotate_left(self, z):
    y = z.right
    T2 = y.left
    y.left = z
    z.right = T2
    z.height = 1 + max(self._get_height(z.left), self._get_height(z.right))
    y.height = 1 + max(self._get_height(y.left), self._get_height(y.right))
    return y

def _rotate_right(self, y):
    x = y.left
    T2 = x.right
    x.right = y
    y.left = T2
    y.height = 1 + max(self._get_height(y.left), self._get_height(y.right))
    x.height = 1 + max(self._get_height(x.left), self._get_height(x.right))
    return x

def preorder(self):
    return self._preorder(self.root)

def _preorder(self, node):
    if not node:
        return []
    return [node.value] + self._preorder(node.left) + self._preorder(node.right)
n = int(input().strip())
sequence = list(map(int, input().strip().split()))

avl = AVL()
for value in sequence:
    avl.insert(value)

print(' '.join(map(str, avl.preorder())))
```

#### ï¼ˆ6ï¼‰å¹¶æŸ¥é›†ï¼ˆDisjoint Setï¼‰

åœ¨å¹¶æŸ¥é›†ä¸­ï¼Œæ¯ä¸ªå…ƒç´ éƒ½å±äºä¸€ä¸ªé›†åˆï¼Œå¹¶ä¸”è¿™äº›é›†åˆä¹‹é—´æ˜¯ä¸ç›¸äº¤çš„ã€‚ä¸ºäº†é«˜æ•ˆåœ°å®ç°å¹¶æŸ¥é›†æ“ä½œï¼Œé€šå¸¸ä¼šä½¿ç”¨æ ‘å½¢ç»“æ„æ¥è¡¨ç¤ºé›†åˆä¹‹é—´çš„å…³ç³»ã€‚æ¯ä¸ªé›†åˆå¯ä»¥ç”¨ä¸€ä¸ªæ ‘è¡¨ç¤ºï¼Œå…¶ä¸­æ ‘çš„æ ¹èŠ‚ç‚¹æ˜¯é›†åˆçš„ä»£è¡¨å…ƒç´ ã€‚ä½¿ç”¨é‚»æ¥è¡¨æ¥è¡¨ç¤ºè¿™ç§æ ‘å½¢ç»“æ„æ˜¯ä¸€ç§å¸¸è§çš„åšæ³•ï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨å…¶çˆ¶èŠ‚ç‚¹çš„æŒ‡é’ˆã€‚

**å‰ç¼€æ ‘ï¼ˆTrie Treeï¼‰**ï¼šå‰ç¼€æ ‘æ˜¯ä¸€ç§ç”¨äºå­˜å‚¨å­—ç¬¦ä¸²é›†åˆçš„æ•°æ®ç»“æ„ï¼Œé€šå¸¸ç”¨äºå¿«é€Ÿåœ°è¿›è¡Œå­—ç¬¦ä¸²åŒ¹é…å’Œæœç´¢ã€‚åœ¨å‰ç¼€æ ‘ä¸­ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä»£è¡¨ä¸€ä¸ªå­—ç¬¦ï¼Œä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„è¡¨ç¤ºä¸€ä¸ªå­—ç¬¦ä¸²ã€‚ä¸ºäº†è¡¨ç¤ºå­—ç¬¦ä¸²çš„ç»“æ„ï¼Œé€šå¸¸ä¼šä½¿ç”¨é‚»æ¥è¡¨æ¥è¡¨ç¤ºå‰ç¼€æ ‘ï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨ä¸€ä¸ªå­—ç¬¦ä»¥åŠæŒ‡å‘å­èŠ‚ç‚¹çš„æŒ‡é’ˆåˆ—è¡¨ã€‚

##### ä¾‹15.é£Ÿç‰©é“¾

http://cs101.openjudge.cn/practice/01182

```python
class DisjointSet:
    def __init__(self, n):
        #è®¾[1,n] åŒºé—´è¡¨ç¤ºåŒç±»ï¼Œ[n+1,2*n]è¡¨ç¤ºxåƒçš„åŠ¨ç‰©ï¼Œ[2*n+1,3*n]è¡¨ç¤ºåƒxçš„åŠ¨ç‰©ã€‚
        self.parent = [i for i in range(3 * n + 1)] # æ¯ä¸ªåŠ¨ç‰©æœ‰ä¸‰ç§å¯èƒ½çš„ç±»å‹ï¼Œç”¨ 3 * n æ¥è¡¨ç¤ºæ¯ç§ç±»å‹çš„å¹¶æŸ¥é›†
        self.rank = [0] * (3 * n + 1)

    def find(self, u):
        if self.parent[u] != u:
            self.parent[u] = self.find(self.parent[u])
        return self.parent[u]
    
    def union(self, u, v):
        pu, pv = self.find(u), self.find(v)
        if pu == pv:
            return False
        if self.rank[pu] > self.rank[pv]:
            self.parent[pv] = pu
        elif self.rank[pu] < self.rank[pv]:
            self.parent[pu] = pv
        else:
            self.parent[pv] = pu
            self.rank[pu] += 1
        return True


def is_valid(n, k, statements):
    dsu = DisjointSet(n)

    def find_disjoint_set(x):
        if x > n:
            return False
        return True
    
    false_count = 0
    for d, x, y in statements:
        if not find_disjoint_set(x) or not find_disjoint_set(y):
            false_count += 1
            continue
        if d == 1:  # X and Y are of the same type
            if dsu.find(x) == dsu.find(y + n) or dsu.find(x) == dsu.find(y + 2 * n):
                false_count += 1
            else:
                dsu.union(x, y)
                dsu.union(x + n, y + n)
                dsu.union(x + 2 * n, y + 2 * n)
        else:  # X eats Y
            if dsu.find(x) == dsu.find(y) or dsu.find(x + 2*n) == dsu.find(y):
                false_count += 1
            else: #[1,n] åŒºé—´è¡¨ç¤ºåŒç±»ï¼Œ[n+1,2*n]è¡¨ç¤ºxåƒçš„åŠ¨ç‰©ï¼Œ[2*n+1,3*n]è¡¨ç¤ºåƒxçš„åŠ¨ç‰©
                dsu.union(x + n, y)
                dsu.union(x, y + 2 * n)
                dsu.union(x + 2 * n, y + n)
    
    return false_count

if __name__ == "__main__":
    N, K = map(int, input().split())
    statements = []
    for _ in range(K):
        D, X, Y = map(int, input().split())
        statements.append((D, X, Y))
    result = is_valid(N, K, statements)
    print(result)
```



### äº”.å›¾

#### ï¼ˆ1ï¼‰éƒ¨åˆ†å®šä¹‰æ¦‚å¿µï¼š

å®Œå…¨å›¾ï¼ˆç®€å•å®Œå…¨å›¾ï¼‰ï¼šä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´éƒ½æœ‰è¾¹
è¿é€šå›¾ï¼ˆä¸€èˆ¬æŒ‡æ— å‘å›¾ï¼‰ï¼šå›¾ä¸­ä»»æ„ä¸¤é¡¶ç‚¹è¿é€š
è¿é€šåˆ†é‡ï¼šæ— å‘å›¾çš„æå¤§è¿é€šå­å›¾ï¼ˆç±»ä¼¼å…¨é›†çš„æ¦‚å¿µï¼‰
æå°è¿é€šåˆ†é‡ï¼šåœ¨ä¿æŒè¿é€šçš„æƒ…å†µä¸‹ä½¿è¾¹æ•°æœ€å°‘çš„å­å›¾ï¼ˆæš—æŒ‡æ— å‘å›¾ï¼‰
å¼ºè¿é€šå›¾ï¼ˆç‰¹æŒ‡æœ‰å‘å›¾ï¼‰ï¼šä»»æ„ä¸€å¯¹é¡¶ç‚¹éƒ½æ˜¯å¼ºè¿é€šçš„
å¼ºè¿é€šåˆ†é‡ï¼šæœ‰å‘å›¾ä¸­çš„æå¤§å¼ºè¿é€šå­å›¾
ç”Ÿæˆæ ‘ï¼šåŒ…å«å›¾ä¸­å…¨éƒ¨é¡¶ç‚¹çš„ä¸€ä¸ªæå°è¿é€šå­å›¾

å¼ºè¿é€šåˆ†æ”¯ï¼šå±€éƒ¨æå¤§å¼ºè¿é€šå­å›¾ï¼Œä¸€ä¸ªå›¾ä¸­å¯èƒ½ä¸æ­¢ä¸€ä¸ªå¼ºè¿é€šåˆ†æ”¯

#### ï¼ˆ2ï¼‰åˆ¤æ–­æ— å‘å›¾æ˜¯å¦è¿é€šï¼ˆæœ‰å›è·¯ï¼‰

```python
class Node:
def __init__(self, v):
        self.value = v
        self.joint = set()
"""åˆ¤æ–­æ˜¯å¦è¿é€š"""
def connected(x, visited, num):
    visited.add(x)
    al = 1
    q = [x]
    while al != num and q:
        x = q.pop(0)
        for y in x.joint:
            if y not in visited:
                visited.add(y)
                al += 1
                q.append(y)
    return al == num
"""åˆ¤æ–­æ˜¯å¦æœ‰ç¯"""
def loop(x, visited, parent):
    visited.add(x)
    if x.joint:
        for a in x.joint:
            if a in visited and a != parent:
                return True
            elif a != parent and loop(a, visited, x):
                return True
    return False
n, m = map(int, input().split())
vertex = [Node(i) for i in range(n)]
for i in range(m):
    a, b = map(int, input().split())
    vertex[a].joint.add(vertex[b])
    vertex[b].joint.add(vertex[a])
if connected(vertex[0], set(), n):
    print('connected:yes')
else:
    print('connected:no')
x=0
for i in range(n):
    if loop(vertex[i],set(),None):
        print('loop:yes')
        x=1
        break
if x==0:
    print('loop:no')
```

#### ï¼ˆ3ï¼‰åˆ¤æ–­æœ‰å‘å›¾æ˜¯å¦æœ‰ç¯ï¼šæ‹“æ‰‘æ’åº

åŸç†ï¼šæ¯æ¬¡é€‰å…¥åº¦ä¸º0çš„ç‚¹ï¼Œå°†è¯¥ç‚¹æ”¾å…¥outputï¼Œå¹¶åˆ æ‰è¯¥ç‚¹çš„å‡ºè¾¹ï¼ŒåŒæ—¶æ›´æ–°å…¶ä»–ç‚¹çš„å…¥åº¦ã€‚

å¦‚æœæœ€åoutputçš„é•¿åº¦ä¸ºnåˆ™è¯´æ˜æ— ç¯

```python
class Node:
    def __init__(self, v):
        self.val = v
        self.to = []
from collections import deque
t = int(input())
for _ in range(t):
    n, m = map(int, input().split())
    node = [Node(i) for i in range(1, n + 1)]
    into = [0 for _ in range(n)] 
    for _ in range(m): 
        x, y = map(int, input().split())
        node[x - 1].to.append(node[y - 1])
        into[y - 1] += 1
    queue = deque([node[i] for i in range(n) if into[i] == 0])
    output = []
    while queue:
        a = queue.popleft()
        output.append(a)
        for x in a.to:
            num = x.val
            into[num - 1] -= 1
            if into[num - 1] == 0:
                queue.append(x)
    if len(output) == n:
        print('No')
    else:#å¦åˆ™è¯´æ˜æœ‰ç¯
        print('Yes')
```

#### ï¼ˆ4ï¼‰å›¾çš„éå†

**â‘ å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰**

##### ä¾‹16.è¯æ¢¯

http://cs101.openjudge.cn/practice/28046/

```python
from collections import deque
def check(a, b):
    for k in range(len(a)):
        if a[k] == '_':
            continue
        if a[k] != b[k]:
            return False
    return True

n = int(input())
graph = {}
degree = {}
vis = {}
for _ in range(n):
    word = input()
    vis[word] = False
    for p in range(4):
        tmp = word[:p]+'_'+word[p+1:]
        if word[:p]+'_'+word[p+1:] not in graph:
            graph[tmp] = [word]
            degree[tmp] = 1
        else:
            graph[tmp].append(word)
            degree[tmp] += 1

def bfs():
    start, ending = input().split()
    queue = deque()
    queue.append([start, [start]])
    vis[start] = True
    for p in range(4):
        tmp = start[:p] + '_' + start[p + 1:]
        degree[tmp] -= 1
    while queue:
        wd, now = queue.popleft()
        if wd == ending:
            print(*now)
            return
        for p in range(4):
            tmp = wd[:p] + '_' + wd[p + 1:]
            if degree[tmp] > 0:
                for wor in graph[tmp]:
                    if not vis[wor]:
                        vis[wor] = True
                        degree[tmp] -= 1
                        queue.append([wor, now + [wor]])
    print('NO')
bfs()
```

**â‘¡æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰**

##### ä¾‹17.é©¬èµ°æ—¥

http://cs101.openjudge.cn/practice/04123

    import sys
    
    class Graph:
        def __init__(self):
            self.vertices = {}
            self.num_vertices = 0
    def add_vertex(self, key):
        self.num_vertices = self.num_vertices + 1
        new_ertex = Vertex(key)
        self.vertices[key] = new_ertex
        return new_ertex
    
    def get_vertex(self, n):
        if n in self.vertices:
            return self.vertices[n]
        else:
            return None
    
    def __len__(self):
        return self.num_vertices
    
    def __contains__(self, n):
        return n in self.vertices
    
    def add_edge(self, f, t, cost=0):
        if f not in self.vertices:
            nv = self.add_vertex(f)
        if t not in self.vertices:
            nv = self.add_vertex(t)
        self.vertices[f].add_neighbor(self.vertices[t], cost)   
    
    def getVertices(self):
        return list(self.vertices.keys())
    
    def __iter__(self):
        return iter(self.vertices.values())
    class Vertex:
        def __init__(self, num):
            self.key = num
            self.connectedTo = {}
            self.color = 'white'
            self.distance = sys.maxsize
            self.previous = None
            self.disc = 0
            self.fin = 0
    def __lt__(self,o):
        return self.key < o.key
    
    def add_neighbor(self, nbr, weight=0):
        self.connectedTo[nbr] = weight
    
    def get_neighbors(self):
        return self.connectedTo.keys()
    
    def __str__(self):
        return str(self.key) + ":color " + self.color + ":disc " + str(self.disc) + ":fin " + str(
            self.fin) + ":dist " + str(self.distance) + ":pred \n\t[" + str(self.previous) + "]\n"
    def knight_graph(board_size):
        kt_graph = Graph()
        for row in range(board_size):           #éå†æ¯ä¸€è¡Œ
            for col in range(board_size):       #éå†è¡Œä¸Šçš„æ¯ä¸€ä¸ªæ ¼å­
                node_id = pos_to_node_id(row, col, board_size) #æŠŠè¡Œã€åˆ—å·è½¬ä¸ºæ ¼å­ID
                new_positions = gen_legal_moves(row, col, board_size) #æŒ‰ç…§ é©¬èµ°æ—¥ï¼Œè¿”å›ä¸‹ä¸€æ­¥å¯èƒ½ä½ç½®
                for row2, col2 in new_positions:
                    other_node_id = pos_to_node_id(row2, col2, board_size) #ä¸‹ä¸€æ­¥çš„æ ¼å­ID
                    kt_graph.add_edge(node_id, other_node_id)
        return kt_graph
    
    def pos_to_node_id(x, y, bdSize):
        return x * bdSize + y
    
    def gen_legal_moves(row, col, board_size):
        new_moves = []
        move_offsets = [                        # é©¬èµ°æ—¥çš„8ç§èµ°æ³•
            (-1, -2), 
            (-1, 2), 
            (-2, -1),  
            (-2, 1),  
            (1, -2), 
            (1, 2), 
            (2, -1),  
            (2, 1),  
        ]
        for r_off, c_off in move_offsets:
            if (                                
                0 <= row + r_off < board_size
                and 0 <= col + c_off < board_size
            ):
                new_moves.append((row + r_off, col + c_off))
        return new_moves
    
    
    def knight_tour(n, path, u, limit):
        u.color = "gray"
        path.append(u)              #å½“å‰é¡¶ç‚¹æ¶‚è‰²å¹¶åŠ å…¥è·¯å¾„
        if n < limit:
            neighbors = ordered_by_avail(u) #å¯¹æ‰€æœ‰çš„åˆæ³•ç§»åŠ¨ä¾æ¬¡æ·±å…¥
            i = 0    
        for nbr in neighbors:
            if nbr.color == "white" and \
                knight_tour(n + 1, path, nbr, limit):   #é€‰æ‹©â€œç™½è‰²â€æœªç»æ·±å…¥çš„ç‚¹ï¼Œå±‚æ¬¡åŠ ä¸€ï¼Œé€’å½’æ·±å…¥
                return True
        else:                       #æ‰€æœ‰çš„â€œä¸‹ä¸€æ­¥â€éƒ½è¯•äº†èµ°ä¸é€š
            path.pop()              #å›æº¯ï¼Œä»è·¯å¾„ä¸­åˆ é™¤å½“å‰é¡¶ç‚¹
            u.color = "white"       #å½“å‰é¡¶ç‚¹æ”¹å›ç™½è‰²
            return False
    else:
        return True
    def ordered_by_avail(n):
        res_list = []
        for v in n.get_neighbors():
            if v.color == "white":
                c = 0
                for w in v.get_neighbors():
                    if w.color == "white":
                        c += 1
                res_list.append((c,v))
        res_list.sort(key = lambda x: x[0])
        return [y[1] for y in res_list]
    
    def main():
        def NodeToPos(id):
           return ((id//8, id%8))
    bdSize = int(input())  # æ£‹ç›˜å¤§å°
    *start_pos, = map(int, input().split())  # èµ·å§‹ä½ç½®
    g = knight_graph(bdSize)
    start_vertex = g.get_vertex(pos_to_node_id(start_pos[0], start_pos[1], bdSize))
    if start_vertex is None:
        print("fail")
        exit(0)
    
    tour_path = []
    done = knight_tour(0, tour_path, start_vertex, bdSize * bdSize-1)
    if done:
        print("success")
    else:
        print("fail")
    
    exit(0)
    
    # æ‰“å°è·¯å¾„
    cnt = 0
    for vertex in tour_path:
        cnt += 1
        if cnt % bdSize == 0:
            print()
        else:
            print(vertex.key, end=" ")
    if __name__ == '__main__':
        main()

#### ï¼ˆ5ï¼‰å¼ºè¿é€šå›¾

```python
def dfs1(graph, node, visited, stack):
    visited[node] = True
    for neighbor in graph[node]:
        if not visited[neighbor]:
            dfs1(graph, neighbor, visited, stack)
    stack.append(node)

def dfs2(graph, node, visited, component):
    visited[node] = True
    component.append(node)
    for neighbor in graph[node]:
        if not visited[neighbor]:
            dfs2(graph, neighbor, visited, component)

def kosaraju(graph):

   # Step 1: Perform first DFS to get finishing times

   stack = []
   visited = [False] * len(graph)
   for node in range(len(graph)):
       if not visited[node]:
           dfs1(graph, node, visited, stack)

    # Step 2: Transpose the graph
    transposed_graph = [[] for _ in range(len(graph))]
    for node in range(len(graph)):
        for neighbor in graph[node]:
            transposed_graph[neighbor].append(node)
    
    # Step 3: Perform second DFS on the transposed graph to find SCCs
    visited = [False] * len(graph)
    sccs = []
    while stack:
        node = stack.pop()
        if not visited[node]:
            scc = []
            dfs2(transposed_graph, node, visited, scc)
            sccs.append(scc)
    return sccs
```

### å…­.æ’åºç®—æ³•

##### ï¼ˆ1ï¼‰é€‰æ‹©æ’åº

```python
def selection_sort(nums: list[int]):
    """é€‰æ‹©æ’åº"""
    n = len(nums)
    # å¤–å¾ªç¯ï¼šæœªæ’åºåŒºé—´ä¸º [i, n-1]
    for i in range(n - 1):
        # å†…å¾ªç¯ï¼šæ‰¾åˆ°æœªæ’åºåŒºé—´å†…çš„æœ€å°å…ƒç´ 
        k = i
        for j in range(i + 1, n):
            if nums[j] < nums[k]:
                k = j  # è®°å½•æœ€å°å…ƒç´ çš„ç´¢å¼•
        # å°†è¯¥æœ€å°å…ƒç´ ä¸æœªæ’åºåŒºé—´çš„é¦–ä¸ªå…ƒç´ äº¤æ¢
        nums[i], nums[k] = nums[k], nums[i]
```

##### ï¼ˆ2ï¼‰å†’æ³¡æ’åº

```python
def bubble_sort(nums: list[int]):
    """å†’æ³¡æ’åº"""
    n = len(nums)
    # å¤–å¾ªç¯ï¼šæœªæ’åºåŒºé—´ä¸º [0, i]
    for i in range(n - 1, 0, -1):
        # å†…å¾ªç¯ï¼šå°†æœªæ’åºåŒºé—´ [0, i] ä¸­çš„æœ€å¤§å…ƒç´ äº¤æ¢è‡³è¯¥åŒºé—´çš„æœ€å³ç«¯
        for j in range(i):
            if nums[j] > nums[j + 1]:
                # äº¤æ¢ nums[j] ä¸ nums[j + 1]
                nums[j], nums[j + 1] = nums[j + 1], nums[j]
```

##### ï¼ˆ3ï¼‰æ’å…¥æ’åº

```python
def insertion_sort(nums: list[int]):
    """æ’å…¥æ’åº"""
    # å¤–å¾ªç¯ï¼šå·²æ’åºåŒºé—´ä¸º [0, i-1]
    for i in range(1, len(nums)):
        base = nums[i]
        j = i - 1
        # å†…å¾ªç¯ï¼šå°† base æ’å…¥åˆ°å·²æ’åºåŒºé—´ [0, i-1] ä¸­çš„æ­£ç¡®ä½ç½®
        while j >= 0 and nums[j] > base:
            nums[j + 1] = nums[j]  # å°† nums[j] å‘å³ç§»åŠ¨ä¸€ä½
            j -= 1
        nums[j + 1] = base  # å°† base èµ‹å€¼åˆ°æ­£ç¡®ä½ç½®
```

##### ï¼ˆ4ï¼‰å¿«é€Ÿæ’åº

```python
def partition(self, nums: list[int], left: int, right: int) -> int:
    """å“¨å…µåˆ’åˆ†"""
    # ä»¥ nums[left] ä¸ºåŸºå‡†æ•°
    i, j = left, right
    while i < j:
        while i < j and nums[j] >= nums[left]:
            j -= 1  # ä»å³å‘å·¦æ‰¾é¦–ä¸ªå°äºåŸºå‡†æ•°çš„å…ƒç´ 
        while i < j and nums[i] <= nums[left]:
            i += 1  # ä»å·¦å‘å³æ‰¾é¦–ä¸ªå¤§äºåŸºå‡†æ•°çš„å…ƒç´ 
        # å…ƒç´ äº¤æ¢
        nums[i], nums[j] = nums[j], nums[i]
    # å°†åŸºå‡†æ•°äº¤æ¢è‡³ä¸¤å­æ•°ç»„çš„åˆ†ç•Œçº¿
    nums[i], nums[left] = nums[left], nums[i]
    return i  # è¿”å›åŸºå‡†æ•°çš„ç´¢å¼•
```

##### ï¼ˆ5ï¼‰å½’å¹¶æ’åº

```python
def merge(nums: list[int], left: int, mid: int, right: int):
    """åˆå¹¶å·¦å­æ•°ç»„å’Œå³å­æ•°ç»„"""
    # å·¦å­æ•°ç»„åŒºé—´ä¸º [left, mid], å³å­æ•°ç»„åŒºé—´ä¸º [mid+1, right]
    # åˆ›å»ºä¸€ä¸ªä¸´æ—¶æ•°ç»„ tmp ï¼Œç”¨äºå­˜æ”¾åˆå¹¶åçš„ç»“æœ
    tmp = [0] * (right - left + 1)
    # åˆå§‹åŒ–å·¦å­æ•°ç»„å’Œå³å­æ•°ç»„çš„èµ·å§‹ç´¢å¼•
    i, j, k = left, mid + 1, 0
    # å½“å·¦å³å­æ•°ç»„éƒ½è¿˜æœ‰å…ƒç´ æ—¶ï¼Œè¿›è¡Œæ¯”è¾ƒå¹¶å°†è¾ƒå°çš„å…ƒç´ å¤åˆ¶åˆ°ä¸´æ—¶æ•°ç»„ä¸­
    while i <= mid and j <= right:
        if nums[i] <= nums[j]:
           tmp[k] = nums[i]
            i += 1
        else:
            tmp[k] = nums[j]
            j += 1
        k += 1
    # å°†å·¦å­æ•°ç»„å’Œå³å­æ•°ç»„çš„å‰©ä½™å…ƒç´ å¤åˆ¶åˆ°ä¸´æ—¶æ•°ç»„ä¸­
    while i <= mid:
        tmp[k] = nums[i]
        i += 1
        k += 1   
        while j <= right:
        tmp[k] = nums[j]
        j += 1
        k += 1
    # å°†ä¸´æ—¶æ•°ç»„ tmp ä¸­çš„å…ƒç´ å¤åˆ¶å›åŸæ•°ç»„ nums çš„å¯¹åº”åŒºé—´
    for k in range(0, len(tmp)):
        nums[left + k] = tmp[k]
def merge_sort(nums: list[int], left: int, right: int):
    """å½’å¹¶æ’åº"""
    # ç»ˆæ­¢æ¡ä»¶
    if left >= right:
        return  # å½“å­æ•°ç»„é•¿åº¦ä¸º 1 æ—¶ç»ˆæ­¢é€’å½’
    # åˆ’åˆ†é˜¶æ®µ
    mid = (left + right) // 2 # è®¡ç®—ä¸­ç‚¹
    merge_sort(nums, left, mid)  # é€’å½’å·¦å­æ•°ç»„
    merge_sort(nums, mid + 1, right)  # é€’å½’å³å­æ•°ç»„
    # åˆå¹¶é˜¶æ®µ
    merge(nums, left, mid, right)
```

##### ï¼ˆ6ï¼‰å †æ’åº

```python
def sift_down(nums: list[int], n: int, i: int):
    """å †çš„é•¿åº¦ä¸º n ï¼Œä»èŠ‚ç‚¹ i å¼€å§‹ï¼Œä»é¡¶è‡³åº•å †åŒ–"""
    while True:
        # åˆ¤æ–­èŠ‚ç‚¹ i, l, r ä¸­å€¼æœ€å¤§çš„èŠ‚ç‚¹ï¼Œè®°ä¸º ma
        l = 2 * i + 1
        r = 2 * i + 2
        ma = i
        if l < n and nums[l] > nums[ma]:
            ma = l
        if r < n and nums[r] > nums[ma]:
            ma = r
        # è‹¥èŠ‚ç‚¹ i æœ€å¤§æˆ–ç´¢å¼• l, r è¶Šç•Œï¼Œåˆ™æ— é¡»ç»§ç»­å †åŒ–ï¼Œè·³å‡º
        if ma == i:
            break
        # äº¤æ¢ä¸¤èŠ‚ç‚¹
       nums[i], nums[ma] = nums[ma], nums[i]
        # å¾ªç¯å‘ä¸‹å †åŒ–
        i = ma
def heap_sort(nums: list[int]):
    """å †æ’åº"""
    # å»ºå †æ“ä½œï¼šå †åŒ–é™¤å¶èŠ‚ç‚¹ä»¥å¤–çš„å…¶ä»–æ‰€æœ‰èŠ‚ç‚¹
    for i in range(len(nums) // 2 - 1, -1, -1):
        sift_down(nums, len(nums), i)
    # ä»å †ä¸­æå–æœ€å¤§å…ƒç´ ï¼Œå¾ªç¯ n-1 è½®
    for i in range(len(nums) - 1, 0, -1):
        # äº¤æ¢æ ¹èŠ‚ç‚¹ä¸æœ€å³å¶èŠ‚ç‚¹ï¼ˆäº¤æ¢é¦–å…ƒç´ ä¸å°¾å…ƒç´ ï¼‰
        nums[0], nums[i] = nums[i], nums[0]
        # ä»¥æ ¹èŠ‚ç‚¹ä¸ºèµ·ç‚¹ï¼Œä»é¡¶è‡³åº•è¿›è¡Œå †åŒ–
        sift_down(nums, i, 0)
```

##### ï¼ˆ7ï¼‰æ¡¶æ’åº

```python
def bucket_sort(nums: list[float]):
    """æ¡¶æ’åº"""
    # åˆå§‹åŒ– k = n/2 ä¸ªæ¡¶ï¼Œé¢„æœŸå‘æ¯ä¸ªæ¡¶åˆ†é… 2 ä¸ªå…ƒç´ 
    k = len(nums) // 2
    buckets = [[] for _ in range(k)]
    # 1. å°†æ•°ç»„å…ƒç´ åˆ†é…åˆ°å„ä¸ªæ¡¶ä¸­
    for num in nums:
        # è¾“å…¥æ•°æ®èŒƒå›´ä¸º [0, 1)ï¼Œä½¿ç”¨ num * k æ˜ å°„åˆ°ç´¢å¼•èŒƒå›´ [0, k-1]
        i = int(num * k)
        # å°† num æ·»åŠ è¿›æ¡¶ i
        buckets[i].append(num)
    # 2. å¯¹å„ä¸ªæ¡¶æ‰§è¡Œæ’åº
    for bucket in buckets:
        # ä½¿ç”¨å†…ç½®æ’åºå‡½æ•°ï¼Œä¹Ÿå¯ä»¥æ›¿æ¢æˆå…¶ä»–æ’åºç®—æ³•
        bucket.sort()
    # 3. éå†æ¡¶åˆå¹¶ç»“æœ
    i = 0
    for bucket in buckets:
        for num in bucket:
            nums[i] = num
            i += 1
```

##### ï¼ˆ8ï¼‰è®¡æ•°æ’åº

```python
def counting_sort_naive(nums: list[int]):
    """è®¡æ•°æ’åº"""
    # ç®€å•å®ç°ï¼Œæ— æ³•ç”¨äºæ’åºå¯¹è±¡
    # 1. ç»Ÿè®¡æ•°ç»„æœ€å¤§å…ƒç´  m
    m = 0
    for num in nums:
        m = max(m, num)
    # 2. ç»Ÿè®¡å„æ•°å­—çš„å‡ºç°æ¬¡æ•°
    # counter[num] ä»£è¡¨ num çš„å‡ºç°æ¬¡æ•°
    counter = [0] * (m + 1)
    for num in nums:
        counter[num] += 1
    # 3. éå† counter ï¼Œå°†å„å…ƒç´ å¡«å…¥åŸæ•°ç»„ nums
    i = 0
    for num in range(m + 1):
        for _ in range(counter[num]):
            nums[i] = num
            i += 1
```

##### ï¼ˆ9ï¼‰åŸºæ•°æ’åº

```python
def digit(num: int, exp: int) -> int:
    """è·å–å…ƒç´  num çš„ç¬¬ k ä½ï¼Œå…¶ä¸­ exp = 10^(k-1)"""
    # ä¼ å…¥ exp è€Œé k å¯ä»¥é¿å…åœ¨æ­¤é‡å¤æ‰§è¡Œæ˜‚è´µçš„æ¬¡æ–¹è®¡ç®—
    return (num // exp) % 10
def counting_sort_digit(nums: list[int], exp: int):
    """è®¡æ•°æ’åºï¼ˆæ ¹æ® nums ç¬¬ k ä½æ’åºï¼‰"""
    # åè¿›åˆ¶çš„ä½èŒƒå›´ä¸º 0~9 ï¼Œå› æ­¤éœ€è¦é•¿åº¦ä¸º 10 çš„æ¡¶æ•°ç»„
    counter = [0] * 10
    n = len(nums)
    # ç»Ÿè®¡ 0~9 å„æ•°å­—çš„å‡ºç°æ¬¡æ•°
    for i in range(n):
        d = digit(nums[i], exp)  # è·å– nums[i] ç¬¬ k ä½ï¼Œè®°ä¸º d
        counter[d] += 1  # ç»Ÿè®¡æ•°å­— d çš„å‡ºç°æ¬¡æ•°
    # æ±‚å‰ç¼€å’Œï¼Œå°†â€œå‡ºç°ä¸ªæ•°â€è½¬æ¢ä¸ºâ€œæ•°ç»„ç´¢å¼•â€
    for i in range(1, 10):
        counter[i] += counter[i - 1]
    # å€’åºéå†ï¼Œæ ¹æ®æ¡¶å†…ç»Ÿè®¡ç»“æœï¼Œå°†å„å…ƒç´ å¡«å…¥ res
    res = [0] * n
    for i in range(n - 1, -1, -1):
        d = digit(nums[i], exp)
        j = counter[d] - 1  # è·å– d åœ¨æ•°ç»„ä¸­çš„ç´¢å¼• j
        res[j] = nums[i]  # å°†å½“å‰å…ƒç´ å¡«å…¥ç´¢å¼• j
        counter[d] -= 1  # å°† d çš„æ•°é‡å‡ 1
    # ä½¿ç”¨ç»“æœè¦†ç›–åŸæ•°ç»„ nums
    for i in range(n):
        nums[i] = res[i]
def radix_sort(nums: list[int]):
    """åŸºæ•°æ’åº"""
    # è·å–æ•°ç»„çš„æœ€å¤§å…ƒç´ ï¼Œç”¨äºåˆ¤æ–­æœ€å¤§ä½æ•°
    m = max(nums)
    # æŒ‰ç…§ä»ä½ä½åˆ°é«˜ä½çš„é¡ºåºéå†
    exp = 1
    while exp <= m:
        # å¯¹æ•°ç»„å…ƒç´ çš„ç¬¬ k ä½æ‰§è¡Œè®¡æ•°æ’åº
        # k = 1 -> exp = 1
        # k = 2 -> exp = 10
        # å³ exp = 10^(k-1)
        counting_sort_digit(nums, exp)
        exp *= 10
```



ç»“æŸï¼ï¼ï¼